{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Documentation: https://commitizen-tools.github.io/commitizen/ About Commitizen is a tool designed for teams. Its main purpose is to define a standard way of committing rules and communicating it (using the cli provided by commitizen). The reasoning behind it is that it is easier to read, and enforces writing descriptive commits. Besides that, having a convention on your commits makes it possible to parse them and use them for something else, like generating automatically the version or a changelog. Commitizen features Command-line utility to create commits with your rules. Defaults: Conventional commits Display information about your commit rules (commands: schema, example, info) Bump version automatically using semantic versioning based on the commits. Read More Generate a changelog using Keep a changelog Requirements Python 3.6+ Git 1.8.5.2 + Installation Global installation sudo pip3 install -U Commitizen Python project You can add it to your local project using one of these: pip install -U commitizen poetry add commitizen --dev macOS On macOS, it can also be installed via homebrew : brew install commitizen Usage Committing Run in your terminal cz commit or the shortcut cz c Integrating with Pre-commit Commitizen can lint your commit message for you with cz check . You can integrate this in your pre-commit config with: --- repos : - repo : https://github.com/commitizen-tools/commitizen rev : master hooks : - id : commitizen stages : [ commit-msg ] After the configuration is added, you'll need to run pre-commit install --hook-type commit-msg Read more about the check command here . Help $ cz --help usage: cz [ -h ] [ --debug ] [ -n NAME ] [ --version ] { init,commit,c,ls,example,info,schema,bump,changelog,ch,check,version } ... Commitizen is a cli tool to generate conventional commits. For more information about the topic go to https://conventionalcommits.org/ optional arguments: -h, --help show this help message and exit --debug use debug mode -n NAME, --name NAME use the given commitizen ( default: cz_conventional_commits ) --version get the version of the installed commitizen commands: { init,commit,c,ls,example,info,schema,bump,changelog,ch,check,version } init init commitizen configuration commit ( c ) create new commit ls show available commitizens example show commit example info show information about the cz schema show commit schema bump bump semantic version based on the git log changelog ( ch ) generate changelog ( note that it will overwrite existing file ) check validates that a commit message matches the commitizen schema version get the version of the installed commitizen or the current project ( default: installed commitizen ) Setting up bash completion When using bash as your shell (limited support for zsh, fish, and tcsh is available), Commitizen can use argcomplete for auto-completion. For this argcomplete needs to be enabled. argcomplete is installed when you install Commitizen since it's a dependency. If Commitizen is installed globally, global activation can be executed: sudo activate-global-python-argcomplete For permanent (but not global) Commitizen activation, use: register-python-argcomplete cz >> ~/.bashrc For one-time activation of argcomplete for Commitizen only, use: eval \" $( register-python-argcomplete cz ) \" For further information on activation, please visit the argcomplete website . Third-Party Commitizen Templates See Third-Party Commitizen Templates . FAQ Why are revert and chore valid types in the check pattern of cz conventional_commits but not types we can select? revert and chore are added to the \"pattern\" in cz check in order to prevent backward errors, but officially they are not part of conventional commits, we are using the latest types from Angular (they used to but were removed). However, you can create a customized cz with those extra types. (See Customization ) See more discussion in issue #142 and #36 How to handle revert commits? git revert --no-commit <SHA> git commit -m \"revert: foo bar\" Contributing See Contributing","title":"Introduction"},{"location":"index.html#about","text":"Commitizen is a tool designed for teams. Its main purpose is to define a standard way of committing rules and communicating it (using the cli provided by commitizen). The reasoning behind it is that it is easier to read, and enforces writing descriptive commits. Besides that, having a convention on your commits makes it possible to parse them and use them for something else, like generating automatically the version or a changelog.","title":"About"},{"location":"index.html#commitizen-features","text":"Command-line utility to create commits with your rules. Defaults: Conventional commits Display information about your commit rules (commands: schema, example, info) Bump version automatically using semantic versioning based on the commits. Read More Generate a changelog using Keep a changelog","title":"Commitizen features"},{"location":"index.html#requirements","text":"Python 3.6+ Git 1.8.5.2 +","title":"Requirements"},{"location":"index.html#installation","text":"Global installation sudo pip3 install -U Commitizen","title":"Installation"},{"location":"index.html#python-project","text":"You can add it to your local project using one of these: pip install -U commitizen poetry add commitizen --dev","title":"Python project"},{"location":"index.html#macos","text":"On macOS, it can also be installed via homebrew : brew install commitizen","title":"macOS"},{"location":"index.html#usage","text":"","title":"Usage"},{"location":"index.html#committing","text":"Run in your terminal cz commit or the shortcut cz c","title":"Committing"},{"location":"index.html#integrating-with-pre-commit","text":"Commitizen can lint your commit message for you with cz check . You can integrate this in your pre-commit config with: --- repos : - repo : https://github.com/commitizen-tools/commitizen rev : master hooks : - id : commitizen stages : [ commit-msg ] After the configuration is added, you'll need to run pre-commit install --hook-type commit-msg Read more about the check command here .","title":"Integrating with Pre-commit"},{"location":"index.html#help","text":"$ cz --help usage: cz [ -h ] [ --debug ] [ -n NAME ] [ --version ] { init,commit,c,ls,example,info,schema,bump,changelog,ch,check,version } ... Commitizen is a cli tool to generate conventional commits. For more information about the topic go to https://conventionalcommits.org/ optional arguments: -h, --help show this help message and exit --debug use debug mode -n NAME, --name NAME use the given commitizen ( default: cz_conventional_commits ) --version get the version of the installed commitizen commands: { init,commit,c,ls,example,info,schema,bump,changelog,ch,check,version } init init commitizen configuration commit ( c ) create new commit ls show available commitizens example show commit example info show information about the cz schema show commit schema bump bump semantic version based on the git log changelog ( ch ) generate changelog ( note that it will overwrite existing file ) check validates that a commit message matches the commitizen schema version get the version of the installed commitizen or the current project ( default: installed commitizen )","title":"Help"},{"location":"index.html#setting-up-bash-completion","text":"When using bash as your shell (limited support for zsh, fish, and tcsh is available), Commitizen can use argcomplete for auto-completion. For this argcomplete needs to be enabled. argcomplete is installed when you install Commitizen since it's a dependency. If Commitizen is installed globally, global activation can be executed: sudo activate-global-python-argcomplete For permanent (but not global) Commitizen activation, use: register-python-argcomplete cz >> ~/.bashrc For one-time activation of argcomplete for Commitizen only, use: eval \" $( register-python-argcomplete cz ) \" For further information on activation, please visit the argcomplete website .","title":"Setting up bash completion"},{"location":"index.html#third-party-commitizen-templates","text":"See Third-Party Commitizen Templates .","title":"Third-Party Commitizen Templates"},{"location":"index.html#faq","text":"","title":"FAQ"},{"location":"index.html#why-are-revert-and-chore-valid-types-in-the-check-pattern-of-cz-conventional_commits-but-not-types-we-can-select","text":"revert and chore are added to the \"pattern\" in cz check in order to prevent backward errors, but officially they are not part of conventional commits, we are using the latest types from Angular (they used to but were removed). However, you can create a customized cz with those extra types. (See Customization ) See more discussion in issue #142 and #36","title":"Why are revert and chore valid types in the check pattern of cz conventional_commits but not types we can select?"},{"location":"index.html#how-to-handle-revert-commits","text":"git revert --no-commit <SHA> git commit -m \"revert: foo bar\"","title":"How to handle revert commits?"},{"location":"index.html#contributing","text":"See Contributing","title":"Contributing"},{"location":"auto_check.html","text":"Automatically check message before commit About To automatically check a commit message prior to committing, you can use a git hook . How to There are two common methods for installing the hook: Method 1: Add git hook through pre-commit Step 1: Install pre-commit python -m pip install pre-commit Step 2: Create .pre-commit-config.yaml at your root directory with the following content --- repos : - repo : https://github.com/commitizen-tools/commitizen rev : v1.17.0 hooks : - id : commitizen stages : [ commit-msg ] Step 3: Install the configuration into git hook through pre-commit pre-commit install --hook-type commit-msg Method 2: Manually add git hook The command might be included inside of a Git hook (inside of .git/hooks/ at the root of the project). The selected hook might be the file called commit-msg. This example shows how to use the check command inside of commit-msg. At the root of the project: cd .git/hooks touch commit-msg chmod +x commit-msg Open the file and edit it: #!/bin/bash MSG_FILE = $1 cz check --commit-msg-file $MSG_FILE Where $1 is the name of the temporary file that contains the current commit message. To be more explicit, the previous variable is stored in another variable called $MSG_FILE , for didactic purposes. The --commit-msg-file flag is required, not optional. Each time you create a commit, automatically, this hook will analyze it. If the commit message is invalid, it'll be rejected. The commit should follow the given committing rules; otherwise, it won't be accepted.","title":"Automatically check message before commit"},{"location":"auto_check.html#automatically-check-message-before-commit","text":"","title":"Automatically check message before commit"},{"location":"auto_check.html#about","text":"To automatically check a commit message prior to committing, you can use a git hook .","title":"About"},{"location":"auto_check.html#how-to","text":"There are two common methods for installing the hook:","title":"How to"},{"location":"auto_check.html#method-1-add-git-hook-through-pre-commit","text":"Step 1: Install pre-commit python -m pip install pre-commit Step 2: Create .pre-commit-config.yaml at your root directory with the following content --- repos : - repo : https://github.com/commitizen-tools/commitizen rev : v1.17.0 hooks : - id : commitizen stages : [ commit-msg ] Step 3: Install the configuration into git hook through pre-commit pre-commit install --hook-type commit-msg","title":"Method 1: Add git hook through pre-commit"},{"location":"auto_check.html#method-2-manually-add-git-hook","text":"The command might be included inside of a Git hook (inside of .git/hooks/ at the root of the project). The selected hook might be the file called commit-msg. This example shows how to use the check command inside of commit-msg. At the root of the project: cd .git/hooks touch commit-msg chmod +x commit-msg Open the file and edit it: #!/bin/bash MSG_FILE = $1 cz check --commit-msg-file $MSG_FILE Where $1 is the name of the temporary file that contains the current commit message. To be more explicit, the previous variable is stored in another variable called $MSG_FILE , for didactic purposes. The --commit-msg-file flag is required, not optional. Each time you create a commit, automatically, this hook will analyze it. If the commit message is invalid, it'll be rejected. The commit should follow the given committing rules; otherwise, it won't be accepted.","title":"Method 2: Manually add git hook"},{"location":"bump.html","text":"About The version is bumped automatically based on the commits. The commits should follow the rules of the committer to be parsed correctly. It is possible to specify a prerelease (alpha, beta, release candidate) version. The version can also be manually bumped. The version format follows semantic versioning . This means MAJOR.MINOR.PATCH Increment Description Conventional commit map MAJOR Breaking changes introduced BREAKING CHANGE MINOR New features feat PATCH Fixes fix + everything else Prereleases are supported following python's PEP 0440 The scheme of this format is [ N! ] N ( .N ) * [{ a | b | rc } N ][ .postN ][ .devN ] Some examples: 0 .9.0 0 .9.1 0 .9.2 0 .9.10 0 .9.11 1 .0.0a0 # alpha 1 .0.0a1 1 .0.0b0 # beta 1 .0.0rc0 # release candidate 1 .0.0rc1 1 .0.0 1 .0.1 1 .1.0 2 .0.0 2 .0.1a post and dev releases are not supported yet. Usage $ cz bump --help usage: cz bump [ -h ] [ --dry-run ] [ --files-only ] [ --changelog ] [ --no-verify ] [ --local-version ] [ --yes ] [ --tag-format TAG_FORMAT ] [ --bump-message BUMP_MESSAGE ] [ --prerelease { alpha,beta,rc }] [ --increment { MAJOR,MINOR,PATCH }] [ --check-consistency ] [ --annotated-tag ] optional arguments: -h, --help show this help message and exit --dry-run show output to stdout, no commit, no modified files --files-only bump version in the files from the config --changelog, -ch generate the changelog for the newest version --no-verify this option bypasses the pre-commit and commit-msg hooks --yes accept automatically questions done --local-version bump the local portion of the version --tag-format TAG_FORMAT the format used to tag the commit and read it, use it in existing projects, wrap around simple quotes --bump-message BUMP_MESSAGE template used to create the release commit, useful when working with CI --prerelease { alpha,beta,rc } , -pr { alpha,beta,rc } choose type of prerelease --increment { MAJOR,MINOR,PATCH } manually specify the desired increment --check-consistency, -cc check consistency among versions defined in commitizen configuration and version_files --annotated-tag, -at create annotated tag instead of lightweight one --files-only Bumps the version in the files defined in version_files without creating a commit and tag on the git repository, cz bump --files-only --changelog Generate a changelog along with the new version and tag when bumping. cz bump --changelog --check-consistency Check whether the versions defined in version_files and the version in commitizen configuration are consistent before bumping version. cz bump --check-consistency For example, if we have pyproject.toml [tool.commitizen] version = \"1.21.0\" version_files = [ \"src/__version__.py\" , \"setup.py\" , ] src/__version__.py , __version__ = \"1.21.0\" and setup.py . ... version = \"1.0.5\" ... If --check-consistency is used, commitizen will check whether the current version in pyproject.toml exists in all version_files and find out it does not exist in setup.py and fails. However, it will still update pyproject.toml and src/__version__.py . To fix it, you'll first git checkout . to reset to the status before trying to bump and update the version in setup.py to 1.21.0 --local-version Bump the local portion of the version. cz bump --local-version For example, if we have pyproject.toml [tool.commitizen] version = \"5.3.5+0.1.0\" If --local-version is used, it will bump only the local version 0.1.0 and keep the public version 5.3.5 intact, bumping to the version 5.3.5+0.2.0 . --annotated-tag If --annotated-tag is used, commitizen will create annotated tags. Also available via configuration, in pyproject.toml or .cz.toml . --changelog-to-stdout If --changelog-to-stdout is used, the incremental changelog generated by the bump will be sent to the stdout, and any other message generated by the bump will be sent to stderr. If --changelog is not used with this command, it is still smart enough to understand that the user wants to create a changelog. It is recommened to be explicit and use --changelog (or the setting update_changelog_on_bump ). This command is useful to \"transport\" the newly created changelog. It can be sent to an auditing system, or to create a Github Release. Example: cz bump --changelog --changelog-to-stdout > body.md Configuration tag_format It is used to read the format from the git tags, and also to generate the tags. Commitizen supports 2 types of formats, a simple and a more complex. cz bump --tag-format = \"v $version \" cz bump --tag-format = \"v $minor . $major . $patch$prerelease \" In your pyproject.toml or .cz.toml [tool.commitizen] tag_format = \"v$minor.$major.$patch$prerelease\" The variables must be preceded by a $ sign. Supported variables: Variable Description $version full generated version $major MAJOR increment $minor MINOR increment $patch PATCH increment $prerelease Prerelase (alpha, beta, release candidate) version_files * It is used to identify the files which should be updated with the new version. It is also possible to provide a pattern for each file, separated by colons ( : ). Commitizen will update it's configuration file automatically ( pyproject.toml , .cz ) when bumping, regarding if the file is present or not in version_files . * Renamed from files to version_files . Some examples pyproject.toml or .cz.toml [tool.commitizen] version_files = [ \"src/__version__.py\" , \"setup.py:version\" ] In the example above, we can see the reference \"setup.py:version\" . This means that it will find a file setup.py and will only make a change in a line containing the version substring. bump_message Template used to specify the commit message generated when bumping. defaults to: bump: version $current_version \u2192 $new_version Variable Description $current_version the version existing before bumping $new_version version generated after bumping Some examples pyproject.toml or .cz.toml [tool.commitizen] bump_message = \"release $current_version \u2192 $new_version [skip-ci]\" update_changelog_on_bump When set to true the changelog is always updated incrementally when running cz bump , so the user does not have to provide the --changelog flag every time. defaults to: false [tool.commitizen] update_changelog_on_bump = true annotated_tag When set to true commitizen will create annotated tags. [tool.commitizen] annotated_tag = true Custom bump Read the customizing section .","title":"Bump"},{"location":"bump.html#about","text":"The version is bumped automatically based on the commits. The commits should follow the rules of the committer to be parsed correctly. It is possible to specify a prerelease (alpha, beta, release candidate) version. The version can also be manually bumped. The version format follows semantic versioning . This means MAJOR.MINOR.PATCH Increment Description Conventional commit map MAJOR Breaking changes introduced BREAKING CHANGE MINOR New features feat PATCH Fixes fix + everything else Prereleases are supported following python's PEP 0440 The scheme of this format is [ N! ] N ( .N ) * [{ a | b | rc } N ][ .postN ][ .devN ] Some examples: 0 .9.0 0 .9.1 0 .9.2 0 .9.10 0 .9.11 1 .0.0a0 # alpha 1 .0.0a1 1 .0.0b0 # beta 1 .0.0rc0 # release candidate 1 .0.0rc1 1 .0.0 1 .0.1 1 .1.0 2 .0.0 2 .0.1a post and dev releases are not supported yet.","title":"About"},{"location":"bump.html#usage","text":"$ cz bump --help usage: cz bump [ -h ] [ --dry-run ] [ --files-only ] [ --changelog ] [ --no-verify ] [ --local-version ] [ --yes ] [ --tag-format TAG_FORMAT ] [ --bump-message BUMP_MESSAGE ] [ --prerelease { alpha,beta,rc }] [ --increment { MAJOR,MINOR,PATCH }] [ --check-consistency ] [ --annotated-tag ] optional arguments: -h, --help show this help message and exit --dry-run show output to stdout, no commit, no modified files --files-only bump version in the files from the config --changelog, -ch generate the changelog for the newest version --no-verify this option bypasses the pre-commit and commit-msg hooks --yes accept automatically questions done --local-version bump the local portion of the version --tag-format TAG_FORMAT the format used to tag the commit and read it, use it in existing projects, wrap around simple quotes --bump-message BUMP_MESSAGE template used to create the release commit, useful when working with CI --prerelease { alpha,beta,rc } , -pr { alpha,beta,rc } choose type of prerelease --increment { MAJOR,MINOR,PATCH } manually specify the desired increment --check-consistency, -cc check consistency among versions defined in commitizen configuration and version_files --annotated-tag, -at create annotated tag instead of lightweight one","title":"Usage"},{"location":"bump.html#-files-only","text":"Bumps the version in the files defined in version_files without creating a commit and tag on the git repository, cz bump --files-only","title":"--files-only"},{"location":"bump.html#-changelog","text":"Generate a changelog along with the new version and tag when bumping. cz bump --changelog","title":"--changelog"},{"location":"bump.html#-check-consistency","text":"Check whether the versions defined in version_files and the version in commitizen configuration are consistent before bumping version. cz bump --check-consistency For example, if we have pyproject.toml [tool.commitizen] version = \"1.21.0\" version_files = [ \"src/__version__.py\" , \"setup.py\" , ] src/__version__.py , __version__ = \"1.21.0\" and setup.py . ... version = \"1.0.5\" ... If --check-consistency is used, commitizen will check whether the current version in pyproject.toml exists in all version_files and find out it does not exist in setup.py and fails. However, it will still update pyproject.toml and src/__version__.py . To fix it, you'll first git checkout . to reset to the status before trying to bump and update the version in setup.py to 1.21.0","title":"--check-consistency"},{"location":"bump.html#-local-version","text":"Bump the local portion of the version. cz bump --local-version For example, if we have pyproject.toml [tool.commitizen] version = \"5.3.5+0.1.0\" If --local-version is used, it will bump only the local version 0.1.0 and keep the public version 5.3.5 intact, bumping to the version 5.3.5+0.2.0 .","title":"--local-version"},{"location":"bump.html#-annotated-tag","text":"If --annotated-tag is used, commitizen will create annotated tags. Also available via configuration, in pyproject.toml or .cz.toml .","title":"--annotated-tag"},{"location":"bump.html#-changelog-to-stdout","text":"If --changelog-to-stdout is used, the incremental changelog generated by the bump will be sent to the stdout, and any other message generated by the bump will be sent to stderr. If --changelog is not used with this command, it is still smart enough to understand that the user wants to create a changelog. It is recommened to be explicit and use --changelog (or the setting update_changelog_on_bump ). This command is useful to \"transport\" the newly created changelog. It can be sent to an auditing system, or to create a Github Release. Example: cz bump --changelog --changelog-to-stdout > body.md","title":"--changelog-to-stdout"},{"location":"bump.html#configuration","text":"","title":"Configuration"},{"location":"bump.html#tag_format","text":"It is used to read the format from the git tags, and also to generate the tags. Commitizen supports 2 types of formats, a simple and a more complex. cz bump --tag-format = \"v $version \" cz bump --tag-format = \"v $minor . $major . $patch$prerelease \" In your pyproject.toml or .cz.toml [tool.commitizen] tag_format = \"v$minor.$major.$patch$prerelease\" The variables must be preceded by a $ sign. Supported variables: Variable Description $version full generated version $major MAJOR increment $minor MINOR increment $patch PATCH increment $prerelease Prerelase (alpha, beta, release candidate)","title":"tag_format"},{"location":"bump.html#version_files","text":"It is used to identify the files which should be updated with the new version. It is also possible to provide a pattern for each file, separated by colons ( : ). Commitizen will update it's configuration file automatically ( pyproject.toml , .cz ) when bumping, regarding if the file is present or not in version_files . * Renamed from files to version_files . Some examples pyproject.toml or .cz.toml [tool.commitizen] version_files = [ \"src/__version__.py\" , \"setup.py:version\" ] In the example above, we can see the reference \"setup.py:version\" . This means that it will find a file setup.py and will only make a change in a line containing the version substring.","title":"version_files *"},{"location":"bump.html#bump_message","text":"Template used to specify the commit message generated when bumping. defaults to: bump: version $current_version \u2192 $new_version Variable Description $current_version the version existing before bumping $new_version version generated after bumping Some examples pyproject.toml or .cz.toml [tool.commitizen] bump_message = \"release $current_version \u2192 $new_version [skip-ci]\"","title":"bump_message"},{"location":"bump.html#update_changelog_on_bump","text":"When set to true the changelog is always updated incrementally when running cz bump , so the user does not have to provide the --changelog flag every time. defaults to: false [tool.commitizen] update_changelog_on_bump = true","title":"update_changelog_on_bump"},{"location":"bump.html#annotated_tag","text":"When set to true commitizen will create annotated tags. [tool.commitizen] annotated_tag = true","title":"annotated_tag"},{"location":"bump.html#custom-bump","text":"Read the customizing section .","title":"Custom bump"},{"location":"changelog.html","text":"About This command will generate a changelog following the committing rules established. Usage $ cz changelog --help usage: cz changelog [ -h ] [ --dry-run ] [ --file-name FILE_NAME ] [ --unreleased-version UNRELEASED_VERSION ] [ --incremental ] [ --start-rev START_REV ] optional arguments: -h, --help show this help message and exit --dry-run show changelog to stdout --file-name FILE_NAME file name of changelog ( default: 'CHANGELOG.md' ) --unreleased-version UNRELEASED_VERSION set the value for the new version ( use the tag value ) , instead of using unreleased --incremental generates changelog from last created version, useful if the changelog has been manually modified --start-rev START_REV start rev of the changelog.If not set, it will generate changelog from the start Examples cz changelog cz ch Constrains changelog generation is constrained only to markdown files. Description These are the variables used by the changelog generator. # <version> (<date>) ## <change_type> - **<scope>** : <message> It will create a full block like above per version found in the tags. And it will create a list of the commits found. The change_type and the scope are optional, they don't need to be provided, but if your regex does they will be rendered. The format followed by the changelog is the one from keep a changelog and the following variables are expected: Variable Description Source version Version number which should follow semver tags date Date in which the tag was created tags change_type The group where the commit belongs to, this is optional. Example: fix commit regex message * Information extracted from the commit message commit regex scope Contextual information. Should be parsed using the regex from the message, it will be bold commit regex breaking Whether is a breaking change or not commit regex required : is the only one required to be parsed by the regex Configuration unreleased_version There is usually an egg and chicken situation when automatically bumping the version and creating the changelog. If you bump the version first, you have no changelog, you have to create it later, and it won't be included in the release of the created version. If you create the changelog before bumping the version, then you usually don't have the latest tag, and the Unreleased title appears. By introducing unreleased_version you can prevent this situation. Before bumping you can run: cz changelog --unreleased-version = \"v1.0.0\" Remember to use the tag instead of the raw version number For example if the format of your tag includes a v ( v1.0.0 ), then you should use that, if your tag is the same as the raw version, then ignore this. Alternatively you can directly bump the version and create the changelog by doing cz bump --changelog file-name This value can be updated in the toml file with the key changelog_file under tools.commitizen Specify the name of the output file, remember that changelog only works with markdown. cz changelog --file-name = \"CHANGES.md\" incremental This flag can be set in the toml file with the key changelog_incremental under tools.commitizen Benefits: Build from latest version found in changelog, this is useful if you have a different changelog and want to use commitizen Update unreleased area Allows users to manually touch the changelog without being rewritten. cz changelog --incremental [tools.commitizen] # ... changelog_incremental = true start-rev This value can be set in the toml file with the key changelog_start_rev under tools.commitizen Start from a given git rev to generate the changelog. Commits before that rev will not be considered. This is especially useful for long-running projects adopting conventional commits, where old commit messages might fail to be parsed for changelog generation. cz changelog --start-rev = \"v0.2.0\" [tools.commitizen] # ... changelog_start_rev = \"v0.2.0\" Hooks Supported hook methods: per parsed message: useful to add links end of changelog generation: useful to send slack or chat message, or notify another department Read more about hooks in the customization page","title":"Changelog"},{"location":"changelog.html#about","text":"This command will generate a changelog following the committing rules established.","title":"About"},{"location":"changelog.html#usage","text":"$ cz changelog --help usage: cz changelog [ -h ] [ --dry-run ] [ --file-name FILE_NAME ] [ --unreleased-version UNRELEASED_VERSION ] [ --incremental ] [ --start-rev START_REV ] optional arguments: -h, --help show this help message and exit --dry-run show changelog to stdout --file-name FILE_NAME file name of changelog ( default: 'CHANGELOG.md' ) --unreleased-version UNRELEASED_VERSION set the value for the new version ( use the tag value ) , instead of using unreleased --incremental generates changelog from last created version, useful if the changelog has been manually modified --start-rev START_REV start rev of the changelog.If not set, it will generate changelog from the start","title":"Usage"},{"location":"changelog.html#examples","text":"cz changelog cz ch","title":"Examples"},{"location":"changelog.html#constrains","text":"changelog generation is constrained only to markdown files.","title":"Constrains"},{"location":"changelog.html#description","text":"These are the variables used by the changelog generator. # <version> (<date>) ## <change_type> - **<scope>** : <message> It will create a full block like above per version found in the tags. And it will create a list of the commits found. The change_type and the scope are optional, they don't need to be provided, but if your regex does they will be rendered. The format followed by the changelog is the one from keep a changelog and the following variables are expected: Variable Description Source version Version number which should follow semver tags date Date in which the tag was created tags change_type The group where the commit belongs to, this is optional. Example: fix commit regex message * Information extracted from the commit message commit regex scope Contextual information. Should be parsed using the regex from the message, it will be bold commit regex breaking Whether is a breaking change or not commit regex required : is the only one required to be parsed by the regex","title":"Description"},{"location":"changelog.html#configuration","text":"","title":"Configuration"},{"location":"changelog.html#unreleased_version","text":"There is usually an egg and chicken situation when automatically bumping the version and creating the changelog. If you bump the version first, you have no changelog, you have to create it later, and it won't be included in the release of the created version. If you create the changelog before bumping the version, then you usually don't have the latest tag, and the Unreleased title appears. By introducing unreleased_version you can prevent this situation. Before bumping you can run: cz changelog --unreleased-version = \"v1.0.0\" Remember to use the tag instead of the raw version number For example if the format of your tag includes a v ( v1.0.0 ), then you should use that, if your tag is the same as the raw version, then ignore this. Alternatively you can directly bump the version and create the changelog by doing cz bump --changelog","title":"unreleased_version"},{"location":"changelog.html#file-name","text":"This value can be updated in the toml file with the key changelog_file under tools.commitizen Specify the name of the output file, remember that changelog only works with markdown. cz changelog --file-name = \"CHANGES.md\"","title":"file-name"},{"location":"changelog.html#incremental","text":"This flag can be set in the toml file with the key changelog_incremental under tools.commitizen Benefits: Build from latest version found in changelog, this is useful if you have a different changelog and want to use commitizen Update unreleased area Allows users to manually touch the changelog without being rewritten. cz changelog --incremental [tools.commitizen] # ... changelog_incremental = true","title":"incremental"},{"location":"changelog.html#start-rev","text":"This value can be set in the toml file with the key changelog_start_rev under tools.commitizen Start from a given git rev to generate the changelog. Commits before that rev will not be considered. This is especially useful for long-running projects adopting conventional commits, where old commit messages might fail to be parsed for changelog generation. cz changelog --start-rev = \"v0.2.0\" [tools.commitizen] # ... changelog_start_rev = \"v0.2.0\"","title":"start-rev"},{"location":"changelog.html#hooks","text":"Supported hook methods: per parsed message: useful to add links end of changelog generation: useful to send slack or chat message, or notify another department Read more about hooks in the customization page","title":"Hooks"},{"location":"check.html","text":"Check About This feature checks whether the commit message follows the given committing rules. If you want to setup an automatic check before every git commit, please refer to Automatically check message before commit . Usage There are three arguments that you can use one of them to check commit message. Git Rev Range If you'd like to check a commit's message after it has already been created, then you can specify the range of commits to check with --rev-range REV_RANGE . $ cz check --rev-range REV_RANGE For example, if you'd like to check all commits on a branch, you can use --rev-range master..HEAD . Or, if you'd like to check all commits starting from when you first implemented commit message linting, you can use --rev-range <first_commit_sha>..HEAD . For more info on how git commit ranges work, you can check the git documentation . Commit Message There are two ways you can provide your plain message and check it. Method 1: use -m or --message $ cz check --message MESSAGE In this option, MESSAGE is the commit message to be checked. Method 2: use pipe to pipe it to cz check $ echo MESSAGE | cz check In this option, MESSAGE is piped to cz check and would be checked. Commit Message File $ cz check --commit-msg-file COMMIT_MSG_FILE In this option, COMMIT_MSG_FILE is the path of the temporal file that contains the commit message. This argument can be useful when cooperating with git hook, please check Automatically check message before commit for more information about how to use this argument with git hook.","title":"Check"},{"location":"check.html#check","text":"","title":"Check"},{"location":"check.html#about","text":"This feature checks whether the commit message follows the given committing rules. If you want to setup an automatic check before every git commit, please refer to Automatically check message before commit .","title":"About"},{"location":"check.html#usage","text":"There are three arguments that you can use one of them to check commit message.","title":"Usage"},{"location":"check.html#git-rev-range","text":"If you'd like to check a commit's message after it has already been created, then you can specify the range of commits to check with --rev-range REV_RANGE . $ cz check --rev-range REV_RANGE For example, if you'd like to check all commits on a branch, you can use --rev-range master..HEAD . Or, if you'd like to check all commits starting from when you first implemented commit message linting, you can use --rev-range <first_commit_sha>..HEAD . For more info on how git commit ranges work, you can check the git documentation .","title":"Git Rev Range"},{"location":"check.html#commit-message","text":"There are two ways you can provide your plain message and check it.","title":"Commit Message"},{"location":"check.html#method-1-use-m-or-message","text":"$ cz check --message MESSAGE In this option, MESSAGE is the commit message to be checked.","title":"Method 1: use -m or --message"},{"location":"check.html#method-2-use-pipe-to-pipe-it-to-cz-check","text":"$ echo MESSAGE | cz check In this option, MESSAGE is piped to cz check and would be checked.","title":"Method 2: use pipe to pipe it to cz check"},{"location":"check.html#commit-message-file","text":"$ cz check --commit-msg-file COMMIT_MSG_FILE In this option, COMMIT_MSG_FILE is the path of the temporal file that contains the commit message. This argument can be useful when cooperating with git hook, please check Automatically check message before commit for more information about how to use this argument with git hook.","title":"Commit Message File"},{"location":"config.html","text":"Configuration pyproject.toml or .cz.toml Add an entry to pyproject.toml or .cz.toml . Recommended for python projects. [tool.commitizen] name = \"cz_conventional_commits\" version = \"0.1.0\" version_files = [ \"src/__version__.py\" , \"pyproject.toml:version\" ] style = [ [ \"qmark\" , \"fg:#ff9d00 bold\" ], [ \"question\" , \"bold\" ], [ \"answer\" , \"fg:#ff9d00 bold\" ], [ \"pointer\" , \"fg:#ff9d00 bold\" ], [ \"highlighted\" , \"fg:#ff9d00 bold\" ], [ \"selected\" , \"fg:#cc5454\" ], [ \"separator\" , \"fg:#cc5454\" ], [ \"instruction\" , \"\" ], [ \"text\" , \"\" ], [\"disabled\", \"fg:#858585 italic\"] ] .cz.toml is recommended for other languages projects (js, go, etc). .cz.json or cz.json JSON might be a more common configuration format for non-python projects, so Commitizen supports JSON config files, now. { \"commitizen\" : { \"name\" : \"cz_conventional_commits\" , \"version\" : \"0.1.0\" , \"version_files\" : [ \"src/__version__.py\" , \"pyproject.toml:version\" ], \"style\" : [ [ \"qmark\" , \"fg:#ff9d00 bold\" ], [ \"question\" , \"bold\" ], [ \"answer\" , \"fg:#ff9d00 bold\" ], [ \"pointer\" , \"fg:#ff9d00 bold\" ], [ \"highlighted\" , \"fg:#ff9d00 bold\" ], [ \"selected\" , \"fg:#cc5454\" ], [ \"separator\" , \"fg:#cc5454\" ], [ \"instruction\" , \"\" ], [ \"text\" , \"\" ], [ \"disabled\" , \"fg:#858585 italic\" ] ] } } .cz.yaml or cz.yaml YAML is another format for non-python proyects as well, supported by Commitizen: commitizen : name : cz_conventional_commits version : 0.1.0 version_files : - src/__version__.py - pyproject.toml:version style : - - qmark - fg:#ff9d00 bold - - question - bold - - answer - fg:#ff9d00 bold - - pointer - fg:#ff9d00 bold - - highlighted - fg:#ff9d00 bold - - selected - fg:#cc5454 - - separator - fg:#cc5454 - - instruction - '' - - text - '' - - disabled - fg:#858585 italic Settings Variable Type Default Description name str \"cz_conventional_commits\" Name of the committing rules to use version str None Current version. Example: \"0.1.2\" version_files list [ ] Files were the version will be updated. A pattern to match a line, can also be specified, separated by : See more tag_format str None Format for the git tag, useful for old projects, that use a convention like \"v1.2.1\" . See more bump_message str None Create custom commit message, useful to skip ci. See more changelog_file str CHANGELOG.md filename of exported changelog style list see above Style for the prompts (It will merge this value with default style.) See More (Styling your prompts with your favorite colors) customize dict None This is only supported when config through toml . Custom rules for committing and bumping. See more","title":"Configuration"},{"location":"config.html#configuration","text":"","title":"Configuration"},{"location":"config.html#pyprojecttoml-or-cztoml","text":"Add an entry to pyproject.toml or .cz.toml . Recommended for python projects. [tool.commitizen] name = \"cz_conventional_commits\" version = \"0.1.0\" version_files = [ \"src/__version__.py\" , \"pyproject.toml:version\" ] style = [ [ \"qmark\" , \"fg:#ff9d00 bold\" ], [ \"question\" , \"bold\" ], [ \"answer\" , \"fg:#ff9d00 bold\" ], [ \"pointer\" , \"fg:#ff9d00 bold\" ], [ \"highlighted\" , \"fg:#ff9d00 bold\" ], [ \"selected\" , \"fg:#cc5454\" ], [ \"separator\" , \"fg:#cc5454\" ], [ \"instruction\" , \"\" ], [ \"text\" , \"\" ], [\"disabled\", \"fg:#858585 italic\"] ] .cz.toml is recommended for other languages projects (js, go, etc).","title":"pyproject.toml or .cz.toml"},{"location":"config.html#czjson-or-czjson","text":"JSON might be a more common configuration format for non-python projects, so Commitizen supports JSON config files, now. { \"commitizen\" : { \"name\" : \"cz_conventional_commits\" , \"version\" : \"0.1.0\" , \"version_files\" : [ \"src/__version__.py\" , \"pyproject.toml:version\" ], \"style\" : [ [ \"qmark\" , \"fg:#ff9d00 bold\" ], [ \"question\" , \"bold\" ], [ \"answer\" , \"fg:#ff9d00 bold\" ], [ \"pointer\" , \"fg:#ff9d00 bold\" ], [ \"highlighted\" , \"fg:#ff9d00 bold\" ], [ \"selected\" , \"fg:#cc5454\" ], [ \"separator\" , \"fg:#cc5454\" ], [ \"instruction\" , \"\" ], [ \"text\" , \"\" ], [ \"disabled\" , \"fg:#858585 italic\" ] ] } }","title":".cz.json or cz.json"},{"location":"config.html#czyaml-or-czyaml","text":"YAML is another format for non-python proyects as well, supported by Commitizen: commitizen : name : cz_conventional_commits version : 0.1.0 version_files : - src/__version__.py - pyproject.toml:version style : - - qmark - fg:#ff9d00 bold - - question - bold - - answer - fg:#ff9d00 bold - - pointer - fg:#ff9d00 bold - - highlighted - fg:#ff9d00 bold - - selected - fg:#cc5454 - - separator - fg:#cc5454 - - instruction - '' - - text - '' - - disabled - fg:#858585 italic","title":".cz.yaml or cz.yaml"},{"location":"config.html#settings","text":"Variable Type Default Description name str \"cz_conventional_commits\" Name of the committing rules to use version str None Current version. Example: \"0.1.2\" version_files list [ ] Files were the version will be updated. A pattern to match a line, can also be specified, separated by : See more tag_format str None Format for the git tag, useful for old projects, that use a convention like \"v1.2.1\" . See more bump_message str None Create custom commit message, useful to skip ci. See more changelog_file str CHANGELOG.md filename of exported changelog style list see above Style for the prompts (It will merge this value with default style.) See More (Styling your prompts with your favorite colors) customize dict None This is only supported when config through toml . Custom rules for committing and bumping. See more","title":"Settings"},{"location":"contributing.html","text":"Contributing to commitizen First of all, thank you for taking the time to contribute! \ud83c\udf89 When contributing to commitizen , please first create an issue to discuss the change you wish to make before making a change. If you're a first-time contributor, you can check the issues with good first issue tag. Before making a pull request Fork the repository . Clone the repository from your GitHub. Setup development environment through poetry ( poetry install ). Setup pre-commit hook ( pre-commit install -t pre-commit -t pre-push -t commit-msg ) Check out a new branch and add your modification. Add test cases for all your changes. (We use CodeCov to ensure our test coverage does not drop.) Use commitizen to do git commit. Run ./scripts/format and ./scripts/test to ensure you follow the coding style and the tests pass. Update README.md and CHANGELOG.md for your changes. Send a pull request \ud83d\ude4f","title":"Contributing"},{"location":"contributing.html#contributing-to-commitizen","text":"First of all, thank you for taking the time to contribute! \ud83c\udf89 When contributing to commitizen , please first create an issue to discuss the change you wish to make before making a change. If you're a first-time contributor, you can check the issues with good first issue tag.","title":"Contributing to commitizen"},{"location":"contributing.html#before-making-a-pull-request","text":"Fork the repository . Clone the repository from your GitHub. Setup development environment through poetry ( poetry install ). Setup pre-commit hook ( pre-commit install -t pre-commit -t pre-push -t commit-msg ) Check out a new branch and add your modification. Add test cases for all your changes. (We use CodeCov to ensure our test coverage does not drop.) Use commitizen to do git commit. Run ./scripts/format and ./scripts/test to ensure you follow the coding style and the tests pass. Update README.md and CHANGELOG.md for your changes. Send a pull request \ud83d\ude4f","title":"Before making a pull request"},{"location":"customization.html","text":"Customizing commitizen is not hard at all. We have two different ways to do so. 1. Customize in configuration file This is only supported when configuring through toml or json (e.g., pyproject.toml , .cz.toml , .cz.json , and cz.json ) The basic steps are: Define your custom committing or bumping rules in the configuration file. Declare name = \"cz_customize\" in your configuration file, or add -n cz_customize when running commitizen. Example: [tool.commitizen] name = \"cz_customize\" [tool.commitizen.customize] message_template = \"{{change_type}}:{% if show_message %} {{message}}{% endif %}\" example = \"feature: this feature enable customize through config file\" schema = \"<type>: <body>\" schema_pattern = \"(feature|bug fix):(\\\\s.*)\" bump_pattern = \"^(break|new|fix|hotfix)\" bump_map = { \"break\" = \"MAJOR\" , \"new\" = \"MINOR\" , \"fix\" = \"PATCH\" , \"hotfix\" = \"PATCH\" } change_type_order = [\"BREAKING CHANGE\", \"feat\", \"fix\", \"refactor\", \"perf\"] info_path = \"cz_customize_info.txt\" info = \"\"\" This is customized info \"\"\" [[tool.commitizen.customize.questions]] type = \"list\" name = \"change_type\" choices = [{value = \"feature\", name = \"feature: A new feature.\"}, {value = \"bug fix\", name = \"bug fix: A bug fix.\"}] # choices = [\"feature\", \"fix\"] # short version message = \"Select the type of change you are committing\" [[tool.commitizen.customize.questions]] type = \"input\" name = \"message\" message = \"Body.\" [[tool.commitizen.customize.questions]] type = \"confirm\" name = \"show_message\" message = \"Do you want to add body message in commit?\" The equivalent example for a json config file: { \"commitizen\" : { \"name\" : \"cz_customize\" , \"customize\" : { \"message_template\" : \"{{change_type}}:{% if show_message %} {{message}}{% endif %}\" , \"example\" : \"feature: this feature enable customize through config file\" , \"schema\" : \"<type>: <body>\" , \"schema_pattern\" : \"(feature|bug fix):(\\\\s.*)\" , \"bump_pattern\" : \"^(break|new|fix|hotfix)\" , \"bump_map\" : { \"break\" : \"MAJOR\" , \"new\" : \"MINOR\" , \"fix\" : \"PATCH\" , \"hotfix\" : \"PATCH\" }, \"change_type_order\" : [ \"BREAKING CHANGE\" , \"feat\" , \"fix\" , \"refactor\" , \"perf\" ], \"info_path\" : \"cz_customize_info.txt\" , \"info\" : \"This is customized info\" , \"questions\" : [ { \"type\" : \"list\" , \"name\" : \"change_type\" , \"choices\" : [ { \"value\" : \"feature\" , \"name\" : \"feature: A new feature.\" }, { \"value\" : \"bug fix\" , \"name\" : \"bug fix: A bug fix.\" } ], \"message\" : \"Select the type of change you are committing\" }, { \"type\" : \"input\" , \"name\" : \"message\" , \"message\" : \"Body.\" }, { \"type\" : \"confirm\" , \"name\" : \"show_message\" , \"message\" : \"Do you want to add body message in commit?\" } ] } } } And the correspondent example for a yaml json file: commitizen : name : cz_customize customize : message_template : \"{{change_type}}:{% if show_message %} {{message}}{% endif %}\" example : 'feature: this feature enable customize through config file' schema : \"<type>: <body>\" schema_pattern : \"(feature|bug fix):(\\\\s.*)\" bump_pattern : \"^(break|new|fix|hotfix)\" bump_map : break : MAJOR new : MINOR fix : PATCH hotfix : PATCH change_type_order : [ \"BREAKING CHANGE\" , \"feat\" , \"fix\" , \"refactor\" , \"perf\" ] info_path : cz_customize_info.txt info : This is customized info questions : - type : list name : change_type choices : - value : feature name : 'feature: A new feature.' - value : bug fix name : 'bug fix: A bug fix.' message : Select the type of change you are committing - type : input name : message message : Body. - type : confirm name : show_message message : Do you want to add body message in commit? Customize configuration Parameter Type Default Description questions dict None Questions regarding the commit message. Detailed below. message_template str None The template for generating message from the given answers. message_template should either follow Jinja2 formatting specification, and all the variables in this template should be defined in name in questions example str None (OPTIONAL) Provide an example to help understand the style. Used by cz example . schema str None (OPTIONAL) Show the schema used. Used by cz schema . schema_pattern str None (OPTIONAL) The regular expression used to do commit message validation. Used by cz check . info_path str None (OPTIONAL) The path to the file that contains explanation of the commit rules. Used by cz info . If not provided cz info , will load info instead. info str None (OPTIONAL) Explanation of the commit rules. Used by cz info . bump_map dict None (OPTIONAL) Dictionary mapping the extracted information to a SemVer increment type ( MAJOR , MINOR , PATCH ) bump_pattern str None (OPTIONAL) Regex to extract information from commit (subject and body) change_type_order str None (OPTIONAL) List of strings used to order the Changelog. All other types will be sorted alphabetically. Default is [\"BREAKING CHANGE\", \"feat\", \"fix\", \"refactor\", \"perf\"] Detailed questions content Parameter Type Default Description type str None The type of questions. Valid type: list , input and etc. See More name str None The key for the value answered by user. It's used in message_template message str None Detail description for the question. choices list None (OPTIONAL) The choices when type = list . Either use a list of values or a list of dicitionaries with name and value keys. See examples above. default Any None (OPTIONAL) The default value for this question. filter str None (Optional) Validator for user's answer. (Work in Progress) 2. Customize through customizing a class The basic steps are: Inheriting from BaseCommitizen Give a name to your rules. Expose the class at the end of your file assigning it to discover_this Create a python package starting with cz_ using setup.py , poetry , etc Check an example on how to configure BaseCommitizen . You can also automate the steps above through cookiecutter . cookiecutter gh:commitizen-tools/commitizen_cz_template See commitizen_cz_template for detail. Custom commit rules Create a file starting with cz_ , for example cz_jira.py . This prefix is used to detect the plug-in. Same method flask uses Inherit from BaseCommitizen , and you must define questions and message . The others are optional. from commitizen.cz.base import BaseCommitizen class JiraCz ( BaseCommitizen ): def questions ( self ) -> list : \"\"\"Questions regarding the commit message.\"\"\" questions = [ { 'type' : 'input' , 'name' : 'title' , 'message' : 'Commit title' }, { 'type' : 'input' , 'name' : 'issue' , 'message' : 'Jira Issue number:' }, ] return questions def message ( self , answers : dict ) -> str : \"\"\"Generate the message with the given answers.\"\"\" return ' {0} (# {1} )' . format ( answers [ 'title' ], answers [ 'issue' ]) def example ( self ) -> str : \"\"\"Provide an example to help understand the style (OPTIONAL) Used by `cz example`. \"\"\" return 'Problem with user (#321)' def schema ( self ) -> str : \"\"\"Show the schema used (OPTIONAL) Used by `cz schema`. \"\"\" return '<title> (<issue>)' def info ( self ) -> str : \"\"\"Explanation of the commit rules. (OPTIONAL) Used by `cz info`. \"\"\" return 'We use this because is useful' discover_this = JiraCz # used by the plug-in system The next file required is setup.py modified from flask version. from setuptools import setup setup ( name = 'JiraCommitizen' , version = '0.1.0' , py_modules = [ 'cz_jira' ], license = 'MIT' , long_description = 'this is a long description' , install_requires = [ 'commitizen' ] ) So in the end, we would have . \u251c\u2500\u2500 cz_jira.py \u2514\u2500\u2500 setup.py And that's it. You can install it without uploading to pypi by simply doing pip install . If you feel like it should be part of this repo, create a PR. Custom bump rules You need to define 2 parameters inside your custom BaseCommitizen . Parameter Type Default Description bump_pattern str None Regex to extract information from commit (subject and body) bump_map dict None Dictionary mapping the extracted information to a SemVer increment type ( MAJOR , MINOR , PATCH ) Let's see an example. from commitizen.cz.base import BaseCommitizen class StrangeCommitizen ( BaseCommitizen ): bump_pattern = r \"^(break|new|fix|hotfix)\" bump_map = { \"break\" : \"MAJOR\" , \"new\" : \"MINOR\" , \"fix\" : \"PATCH\" , \"hotfix\" : \"PATCH\" } That's it, your commitizen now supports custom rules, and you can run. cz -n cz_strange bump Custom changelog generator The changelog generator should just work in a very basic manner without touching anything. You can customize it of course, and this are the variables you need to add to your custom BaseCommitizen . Parameter Type Required Description commit_parser str NO Regex which should provide the variables explained in the changelog description changelog_pattern str NO Regex to validate the commits, this is useful to skip commits that don't meet your ruling standards like a Merge. Usually the same as bump_pattern change_type_map dict NO Convert the title of the change type that will appear in the changelog, if a value is not found, the original will be provided changelog_message_builder_hook method: (dict, git.GitCommit) -> dict NO Customize with extra information your message output, like adding links, this function is executed per parsed commit. Each GitCommit contains the following attrs: rev , title , body , author , author_email changelog_hook method: (full_changelog: str, partial_changelog: Optional[str]) -> str NO Receives the whole and partial (if used incremental) changelog. Useful to send slack messages or notify a compliance department. Must return the full_changelog from commitizen.cz.base import BaseCommitizen import chat import compliance class StrangeCommitizen ( BaseCommitizen ): changelog_pattern = r \"^(break|new|fix|hotfix)\" commit_parser = r \"^(?P<change_type>feat|fix|refactor|perf|BREAKING CHANGE)(?:\\((?P<scope>[^()\\r\\n]*)\\)|\\()?(?P<breaking>!)?:\\s(?P<message>.*)?\" change_type_map = { \"feat\" : \"Features\" , \"fix\" : \"Bug Fixes\" , \"refactor\" : \"Code Refactor\" , \"perf\" : \"Performance improvements\" } def changelog_message_builder_hook ( self , parsed_message : dict , commit : git . GitCommit ) -> dict : rev = commit . rev m = parsed_message [ \"message\" ] parsed_message [ \"message\" ] = f \" { m } { rev } [ { commit . author } ]( { commit . author_email } )\" return parsed_message def changelog_hook ( self , full_changelog : str , partial_changelog : Optional [ str ]) -> str : \"\"\"Executed at the end of the changelog generation full_changelog: it's the output about to being written into the file partial_changelog: it's the new stuff, this is useful to send slack messages or similar Return: the new updated full_changelog \"\"\" if partial_changelog : chat . room ( \"#committers\" ) . notify ( partial_changelog ) if full_changelog : compliance . send ( full_changelog ) full_changelog . replace ( ' fix ' , ' **fix** ' ) return full_changelog Raise Customize Exception If you want commitizen to catch your exception and print the message, you'll have to inherit CzException . from commitizen.cz.exception import CzException class NoSubjectProvidedException ( CzException ): ...","title":"Customization"},{"location":"customization.html#1-customize-in-configuration-file","text":"This is only supported when configuring through toml or json (e.g., pyproject.toml , .cz.toml , .cz.json , and cz.json ) The basic steps are: Define your custom committing or bumping rules in the configuration file. Declare name = \"cz_customize\" in your configuration file, or add -n cz_customize when running commitizen. Example: [tool.commitizen] name = \"cz_customize\" [tool.commitizen.customize] message_template = \"{{change_type}}:{% if show_message %} {{message}}{% endif %}\" example = \"feature: this feature enable customize through config file\" schema = \"<type>: <body>\" schema_pattern = \"(feature|bug fix):(\\\\s.*)\" bump_pattern = \"^(break|new|fix|hotfix)\" bump_map = { \"break\" = \"MAJOR\" , \"new\" = \"MINOR\" , \"fix\" = \"PATCH\" , \"hotfix\" = \"PATCH\" } change_type_order = [\"BREAKING CHANGE\", \"feat\", \"fix\", \"refactor\", \"perf\"] info_path = \"cz_customize_info.txt\" info = \"\"\" This is customized info \"\"\" [[tool.commitizen.customize.questions]] type = \"list\" name = \"change_type\" choices = [{value = \"feature\", name = \"feature: A new feature.\"}, {value = \"bug fix\", name = \"bug fix: A bug fix.\"}] # choices = [\"feature\", \"fix\"] # short version message = \"Select the type of change you are committing\" [[tool.commitizen.customize.questions]] type = \"input\" name = \"message\" message = \"Body.\" [[tool.commitizen.customize.questions]] type = \"confirm\" name = \"show_message\" message = \"Do you want to add body message in commit?\" The equivalent example for a json config file: { \"commitizen\" : { \"name\" : \"cz_customize\" , \"customize\" : { \"message_template\" : \"{{change_type}}:{% if show_message %} {{message}}{% endif %}\" , \"example\" : \"feature: this feature enable customize through config file\" , \"schema\" : \"<type>: <body>\" , \"schema_pattern\" : \"(feature|bug fix):(\\\\s.*)\" , \"bump_pattern\" : \"^(break|new|fix|hotfix)\" , \"bump_map\" : { \"break\" : \"MAJOR\" , \"new\" : \"MINOR\" , \"fix\" : \"PATCH\" , \"hotfix\" : \"PATCH\" }, \"change_type_order\" : [ \"BREAKING CHANGE\" , \"feat\" , \"fix\" , \"refactor\" , \"perf\" ], \"info_path\" : \"cz_customize_info.txt\" , \"info\" : \"This is customized info\" , \"questions\" : [ { \"type\" : \"list\" , \"name\" : \"change_type\" , \"choices\" : [ { \"value\" : \"feature\" , \"name\" : \"feature: A new feature.\" }, { \"value\" : \"bug fix\" , \"name\" : \"bug fix: A bug fix.\" } ], \"message\" : \"Select the type of change you are committing\" }, { \"type\" : \"input\" , \"name\" : \"message\" , \"message\" : \"Body.\" }, { \"type\" : \"confirm\" , \"name\" : \"show_message\" , \"message\" : \"Do you want to add body message in commit?\" } ] } } } And the correspondent example for a yaml json file: commitizen : name : cz_customize customize : message_template : \"{{change_type}}:{% if show_message %} {{message}}{% endif %}\" example : 'feature: this feature enable customize through config file' schema : \"<type>: <body>\" schema_pattern : \"(feature|bug fix):(\\\\s.*)\" bump_pattern : \"^(break|new|fix|hotfix)\" bump_map : break : MAJOR new : MINOR fix : PATCH hotfix : PATCH change_type_order : [ \"BREAKING CHANGE\" , \"feat\" , \"fix\" , \"refactor\" , \"perf\" ] info_path : cz_customize_info.txt info : This is customized info questions : - type : list name : change_type choices : - value : feature name : 'feature: A new feature.' - value : bug fix name : 'bug fix: A bug fix.' message : Select the type of change you are committing - type : input name : message message : Body. - type : confirm name : show_message message : Do you want to add body message in commit?","title":"1. Customize in configuration file"},{"location":"customization.html#customize-configuration","text":"Parameter Type Default Description questions dict None Questions regarding the commit message. Detailed below. message_template str None The template for generating message from the given answers. message_template should either follow Jinja2 formatting specification, and all the variables in this template should be defined in name in questions example str None (OPTIONAL) Provide an example to help understand the style. Used by cz example . schema str None (OPTIONAL) Show the schema used. Used by cz schema . schema_pattern str None (OPTIONAL) The regular expression used to do commit message validation. Used by cz check . info_path str None (OPTIONAL) The path to the file that contains explanation of the commit rules. Used by cz info . If not provided cz info , will load info instead. info str None (OPTIONAL) Explanation of the commit rules. Used by cz info . bump_map dict None (OPTIONAL) Dictionary mapping the extracted information to a SemVer increment type ( MAJOR , MINOR , PATCH ) bump_pattern str None (OPTIONAL) Regex to extract information from commit (subject and body) change_type_order str None (OPTIONAL) List of strings used to order the Changelog. All other types will be sorted alphabetically. Default is [\"BREAKING CHANGE\", \"feat\", \"fix\", \"refactor\", \"perf\"]","title":"Customize configuration"},{"location":"customization.html#detailed-questions-content","text":"Parameter Type Default Description type str None The type of questions. Valid type: list , input and etc. See More name str None The key for the value answered by user. It's used in message_template message str None Detail description for the question. choices list None (OPTIONAL) The choices when type = list . Either use a list of values or a list of dicitionaries with name and value keys. See examples above. default Any None (OPTIONAL) The default value for this question. filter str None (Optional) Validator for user's answer. (Work in Progress)","title":"Detailed questions content"},{"location":"customization.html#2-customize-through-customizing-a-class","text":"The basic steps are: Inheriting from BaseCommitizen Give a name to your rules. Expose the class at the end of your file assigning it to discover_this Create a python package starting with cz_ using setup.py , poetry , etc Check an example on how to configure BaseCommitizen . You can also automate the steps above through cookiecutter . cookiecutter gh:commitizen-tools/commitizen_cz_template See commitizen_cz_template for detail.","title":"2. Customize through customizing a class"},{"location":"customization.html#custom-commit-rules","text":"Create a file starting with cz_ , for example cz_jira.py . This prefix is used to detect the plug-in. Same method flask uses Inherit from BaseCommitizen , and you must define questions and message . The others are optional. from commitizen.cz.base import BaseCommitizen class JiraCz ( BaseCommitizen ): def questions ( self ) -> list : \"\"\"Questions regarding the commit message.\"\"\" questions = [ { 'type' : 'input' , 'name' : 'title' , 'message' : 'Commit title' }, { 'type' : 'input' , 'name' : 'issue' , 'message' : 'Jira Issue number:' }, ] return questions def message ( self , answers : dict ) -> str : \"\"\"Generate the message with the given answers.\"\"\" return ' {0} (# {1} )' . format ( answers [ 'title' ], answers [ 'issue' ]) def example ( self ) -> str : \"\"\"Provide an example to help understand the style (OPTIONAL) Used by `cz example`. \"\"\" return 'Problem with user (#321)' def schema ( self ) -> str : \"\"\"Show the schema used (OPTIONAL) Used by `cz schema`. \"\"\" return '<title> (<issue>)' def info ( self ) -> str : \"\"\"Explanation of the commit rules. (OPTIONAL) Used by `cz info`. \"\"\" return 'We use this because is useful' discover_this = JiraCz # used by the plug-in system The next file required is setup.py modified from flask version. from setuptools import setup setup ( name = 'JiraCommitizen' , version = '0.1.0' , py_modules = [ 'cz_jira' ], license = 'MIT' , long_description = 'this is a long description' , install_requires = [ 'commitizen' ] ) So in the end, we would have . \u251c\u2500\u2500 cz_jira.py \u2514\u2500\u2500 setup.py And that's it. You can install it without uploading to pypi by simply doing pip install . If you feel like it should be part of this repo, create a PR.","title":"Custom commit rules"},{"location":"customization.html#custom-bump-rules","text":"You need to define 2 parameters inside your custom BaseCommitizen . Parameter Type Default Description bump_pattern str None Regex to extract information from commit (subject and body) bump_map dict None Dictionary mapping the extracted information to a SemVer increment type ( MAJOR , MINOR , PATCH ) Let's see an example. from commitizen.cz.base import BaseCommitizen class StrangeCommitizen ( BaseCommitizen ): bump_pattern = r \"^(break|new|fix|hotfix)\" bump_map = { \"break\" : \"MAJOR\" , \"new\" : \"MINOR\" , \"fix\" : \"PATCH\" , \"hotfix\" : \"PATCH\" } That's it, your commitizen now supports custom rules, and you can run. cz -n cz_strange bump","title":"Custom bump rules"},{"location":"customization.html#custom-changelog-generator","text":"The changelog generator should just work in a very basic manner without touching anything. You can customize it of course, and this are the variables you need to add to your custom BaseCommitizen . Parameter Type Required Description commit_parser str NO Regex which should provide the variables explained in the changelog description changelog_pattern str NO Regex to validate the commits, this is useful to skip commits that don't meet your ruling standards like a Merge. Usually the same as bump_pattern change_type_map dict NO Convert the title of the change type that will appear in the changelog, if a value is not found, the original will be provided changelog_message_builder_hook method: (dict, git.GitCommit) -> dict NO Customize with extra information your message output, like adding links, this function is executed per parsed commit. Each GitCommit contains the following attrs: rev , title , body , author , author_email changelog_hook method: (full_changelog: str, partial_changelog: Optional[str]) -> str NO Receives the whole and partial (if used incremental) changelog. Useful to send slack messages or notify a compliance department. Must return the full_changelog from commitizen.cz.base import BaseCommitizen import chat import compliance class StrangeCommitizen ( BaseCommitizen ): changelog_pattern = r \"^(break|new|fix|hotfix)\" commit_parser = r \"^(?P<change_type>feat|fix|refactor|perf|BREAKING CHANGE)(?:\\((?P<scope>[^()\\r\\n]*)\\)|\\()?(?P<breaking>!)?:\\s(?P<message>.*)?\" change_type_map = { \"feat\" : \"Features\" , \"fix\" : \"Bug Fixes\" , \"refactor\" : \"Code Refactor\" , \"perf\" : \"Performance improvements\" } def changelog_message_builder_hook ( self , parsed_message : dict , commit : git . GitCommit ) -> dict : rev = commit . rev m = parsed_message [ \"message\" ] parsed_message [ \"message\" ] = f \" { m } { rev } [ { commit . author } ]( { commit . author_email } )\" return parsed_message def changelog_hook ( self , full_changelog : str , partial_changelog : Optional [ str ]) -> str : \"\"\"Executed at the end of the changelog generation full_changelog: it's the output about to being written into the file partial_changelog: it's the new stuff, this is useful to send slack messages or similar Return: the new updated full_changelog \"\"\" if partial_changelog : chat . room ( \"#committers\" ) . notify ( partial_changelog ) if full_changelog : compliance . send ( full_changelog ) full_changelog . replace ( ' fix ' , ' **fix** ' ) return full_changelog","title":"Custom changelog generator"},{"location":"customization.html#raise-customize-exception","text":"If you want commitizen to catch your exception and print the message, you'll have to inherit CzException . from commitizen.cz.exception import CzException class NoSubjectProvidedException ( CzException ): ...","title":"Raise Customize Exception"},{"location":"exit_codes.html","text":"Exit Codes Commitizen handles expected exceptions through CommitizenException and returns different exit codes for different situations. They could be useful if you want to ignore specific errors in your pipeline. These exit codes can be found in commitizen/exceptions.py::ExitCode . Exception Exit Code Description ExpectedExit 0 Expected exit DryRunExit 0 Exit due to passing --dry-run option NoCommitizenFoundException 1 Using a cz (e.g., cz_jira ) that cannot be found in your system NotAGitProjectError 2 Not in a git project NoCommitsFoundError 4 No commit found NoVersionSpecifiedError 4 Version can not be found in configuration file NoPatternMapError 5 bump / changelog pattern or map can not be found in configuration file BumpCommitFailedError 6 Commit error when bumping version BumpTagFailedError 7 Tag error when bumping version NoAnswersError 8 No user response given CommitError 9 git commit error NoCommitBackupError 10 Commit back up file cannot be found NothingToCommitError 11 Nothing in staging to be committed CustomError 12 CzException raised NoCommandFoundError 13 No command found when running commitizen cli (e.g., cz --debug ) InvalidCommitMessageError 14 The commit message does not pass cz check MissingConfigError 15 Configuration missed for cz_customize NoRevisionError 16 No revision found CurrentVersionNotFoundError 17 current version cannot be found in version_files InvalidCommandArgumentError 18 The argument provide to command is invalid (e.g. cz check -commit-msg-file filename --rev-range master.. ) InvalidConfigurationError 19 An error was found in the Commitizen Configuration, such as duplicates in change_type_order","title":"Exit Codes"},{"location":"exit_codes.html#exit-codes","text":"Commitizen handles expected exceptions through CommitizenException and returns different exit codes for different situations. They could be useful if you want to ignore specific errors in your pipeline. These exit codes can be found in commitizen/exceptions.py::ExitCode . Exception Exit Code Description ExpectedExit 0 Expected exit DryRunExit 0 Exit due to passing --dry-run option NoCommitizenFoundException 1 Using a cz (e.g., cz_jira ) that cannot be found in your system NotAGitProjectError 2 Not in a git project NoCommitsFoundError 4 No commit found NoVersionSpecifiedError 4 Version can not be found in configuration file NoPatternMapError 5 bump / changelog pattern or map can not be found in configuration file BumpCommitFailedError 6 Commit error when bumping version BumpTagFailedError 7 Tag error when bumping version NoAnswersError 8 No user response given CommitError 9 git commit error NoCommitBackupError 10 Commit back up file cannot be found NothingToCommitError 11 Nothing in staging to be committed CustomError 12 CzException raised NoCommandFoundError 13 No command found when running commitizen cli (e.g., cz --debug ) InvalidCommitMessageError 14 The commit message does not pass cz check MissingConfigError 15 Configuration missed for cz_customize NoRevisionError 16 No revision found CurrentVersionNotFoundError 17 current version cannot be found in version_files InvalidCommandArgumentError 18 The argument provide to command is invalid (e.g. cz check -commit-msg-file filename --rev-range master.. ) InvalidConfigurationError 19 An error was found in the Commitizen Configuration, such as duplicates in change_type_order","title":"Exit Codes"},{"location":"external_links.html","text":"If you have written over commitizen, make a PR and add the link here \ud83d\udcaa Talks Name Speaker Occasion Language Extra commitizen-tools: What can we gain from crafting a git message convention Wei Lee Taipey.py 2020 June Meetup, Remote Python Pizza 2020 English slides Automating release cycles Santiago Fraire PyAmsterdam June 24, 2020, Online English slides Automatizando Releases con Commitizen y Github Actions Santiago Fraire PyConAr 2020, Remote Espa\u00f1ol slides Articles Python Table Manners - Commitizen: \u898f\u683c\u5316 commit message (Written in Traditional Mandarin) Automating semantic release with commitizen (English)","title":"Resources"},{"location":"external_links.html#talks","text":"Name Speaker Occasion Language Extra commitizen-tools: What can we gain from crafting a git message convention Wei Lee Taipey.py 2020 June Meetup, Remote Python Pizza 2020 English slides Automating release cycles Santiago Fraire PyAmsterdam June 24, 2020, Online English slides Automatizando Releases con Commitizen y Github Actions Santiago Fraire PyConAr 2020, Remote Espa\u00f1ol slides","title":"Talks"},{"location":"external_links.html#articles","text":"Python Table Manners - Commitizen: \u898f\u683c\u5316 commit message (Written in Traditional Mandarin) Automating semantic release with commitizen (English)","title":"Articles"},{"location":"faq.html","text":"Support for PEP621 PEP621 establishes a [project] definition inside pyproject.toml [project] name = \"spam\" version = \"2020.0.0\" Commitizen won't use the project.version as a source of truth because it's a tool aimed for any kind of project. If we were to use it, it would increase the complexity of the tool. Also why wouldn't we support other project files like cargo.toml or package.json ? Instead of supporting all the different project files, you can use version_files inside [tool.commitizen] , and it will cheaply keep any of these project files in sync [tool.commitizen] version = \"2.5.1\" version_files = [ \"pyproject.toml:^version\" , \"cargo.toml:^version\" , \"package.json:\\\"version\\\":\" ] Why are revert and chore valid types in the check pattern of cz conventional_commits but not types we can select? revert and chore are added to the \"pattern\" in cz check in order to prevent backward errors, but officially they are not part of conventional commits, we are using the latest types from Angular (they used to but were removed). However, you can create a customized cz with those extra types. (See Customization See more discussion in issue #142 and #36 How to revert a bump? If for any reason, the created tag and changelog were to be undone, this is the snippet: git tag --delete <created_tag> git reset HEAD~ git reset --hard HEAD This will remove the last tag created, plus the commit containing the update to .cz.toml and the changelog generated for the version. In case the commit was pushed to the server you can remove it by running git push --delete origin <created_tag> Is this project affiliated with the Commitizen JS project? It is not affiliated. Both are used for similar purposes, parsing commits, generating changelog and version we presume. This one is written in python to make integration easier for python projects and the other serves the JS packages. They differ a bit in design, not sure if cz-js does any of this, but these are some of the stuff you can do with this repo (python's commitizen): create custom rules, version bumps and changelog generation, by default we use the popular conventional commits (I think cz-js allows this). single package, install one thing and it will work (cz-js is a monorepo, but you have to install different dependencies AFAIK) pre-commit integration works on any language project, as long as you create the .cz.toml file. Where do they cross paths? If you are using conventional commits in your git history, then you could swap one with the other in theory. Regarding the name, cz-js came first, they used the word commitizen first. When this project was created originally, the creator read \"be a good commitizen\", and thought it was just a cool word that made sense, and this would be a package that helps you be a good \"commit citizen\".","title":"FAQ"},{"location":"faq.html#support-for-pep621","text":"PEP621 establishes a [project] definition inside pyproject.toml [project] name = \"spam\" version = \"2020.0.0\" Commitizen won't use the project.version as a source of truth because it's a tool aimed for any kind of project. If we were to use it, it would increase the complexity of the tool. Also why wouldn't we support other project files like cargo.toml or package.json ? Instead of supporting all the different project files, you can use version_files inside [tool.commitizen] , and it will cheaply keep any of these project files in sync [tool.commitizen] version = \"2.5.1\" version_files = [ \"pyproject.toml:^version\" , \"cargo.toml:^version\" , \"package.json:\\\"version\\\":\" ]","title":"Support for PEP621"},{"location":"faq.html#why-are-revert-and-chore-valid-types-in-the-check-pattern-of-cz-conventional_commits-but-not-types-we-can-select","text":"revert and chore are added to the \"pattern\" in cz check in order to prevent backward errors, but officially they are not part of conventional commits, we are using the latest types from Angular (they used to but were removed). However, you can create a customized cz with those extra types. (See Customization See more discussion in issue #142 and #36","title":"Why are revert and chore valid types in the check pattern of cz conventional_commits but not types we can select?"},{"location":"faq.html#how-to-revert-a-bump","text":"If for any reason, the created tag and changelog were to be undone, this is the snippet: git tag --delete <created_tag> git reset HEAD~ git reset --hard HEAD This will remove the last tag created, plus the commit containing the update to .cz.toml and the changelog generated for the version. In case the commit was pushed to the server you can remove it by running git push --delete origin <created_tag>","title":"How to revert a bump?"},{"location":"faq.html#is-this-project-affiliated-with-the-commitizen-js-project","text":"It is not affiliated. Both are used for similar purposes, parsing commits, generating changelog and version we presume. This one is written in python to make integration easier for python projects and the other serves the JS packages. They differ a bit in design, not sure if cz-js does any of this, but these are some of the stuff you can do with this repo (python's commitizen): create custom rules, version bumps and changelog generation, by default we use the popular conventional commits (I think cz-js allows this). single package, install one thing and it will work (cz-js is a monorepo, but you have to install different dependencies AFAIK) pre-commit integration works on any language project, as long as you create the .cz.toml file. Where do they cross paths? If you are using conventional commits in your git history, then you could swap one with the other in theory. Regarding the name, cz-js came first, they used the word commitizen first. When this project was created originally, the creator read \"be a good commitizen\", and thought it was just a cool word that made sense, and this would be a package that helps you be a good \"commit citizen\".","title":"Is this project affiliated with the Commitizen JS project?"},{"location":"init.html","text":"For new projects, it is possible to run cz init . This command will prompt the user for information about the project and will configure the selected file type ( pyproject.toml , .cz.toml , etc.). This will help you quickly set up your project with commitizen . Currently init is detecting Commit convention rules ( name ). Version detection based on the existing tags ( version ). Tag format, if your tag convention uses, for example v* in front of the version. ( tag_format ) We hope to detect the files where the version is also repeated eventually, like package.json or __version__ .","title":"Init"},{"location":"third-party-commitizen.html","text":"Third-Party Commitizen Templates In addition to the native templates, some alternative commit format templates are available as PyPI packages (installable with pip ). Conventional JIRA Just like conventional commit format, but the scope has been restricted to a JIRA issue format, i.e. project-issueNumber . This standardises scopes in a meaningful way. It can be installed with pip install conventional-JIRA . Commitizen emoji Just like conventional commit format, but with emojis and optionally time spent and related tasks. It can be installed with pip install commitizen-emoji . Usage: cz --name cz_commitizen_emoji commit . Conventional Legacy (cz_legacy) An extension of the conventional commit format to include user-specified legacy change types in the CHANGELOG while preventing the legacy change types from being used in new commit messages cz_legacy can be installed with pip install cz_legacy See the README for instructions on configuration","title":"Third-Party Commitizen Templates"},{"location":"third-party-commitizen.html#third-party-commitizen-templates","text":"In addition to the native templates, some alternative commit format templates are available as PyPI packages (installable with pip ).","title":"Third-Party Commitizen Templates"},{"location":"third-party-commitizen.html#conventional-jira","text":"Just like conventional commit format, but the scope has been restricted to a JIRA issue format, i.e. project-issueNumber . This standardises scopes in a meaningful way. It can be installed with pip install conventional-JIRA .","title":"Conventional JIRA"},{"location":"third-party-commitizen.html#commitizen-emoji","text":"Just like conventional commit format, but with emojis and optionally time spent and related tasks. It can be installed with pip install commitizen-emoji . Usage: cz --name cz_commitizen_emoji commit .","title":"Commitizen emoji"},{"location":"third-party-commitizen.html#conventional-legacy-cz_legacy","text":"An extension of the conventional commit format to include user-specified legacy change types in the CHANGELOG while preventing the legacy change types from being used in new commit messages cz_legacy can be installed with pip install cz_legacy See the README for instructions on configuration","title":"Conventional Legacy (cz_legacy)"},{"location":"tutorials/github_actions.html","text":"Create a new release with Github Actions Automatic bumping of version To execute cz bump in your CI, and push the new commit and the new tag, back to your master branch, we have to: Create a personal access token. Follow the instructions here . And copy the generated key Create a secret called PERSONAL_ACCESS_TOKEN , with the copied key, by going to your project repository and then Settings > Secrets > Add new secret . In your repository create a new file .github/workflows/bumpversion.yml with the following content. Warning If you use GITHUB_TOKEN instead of PERSONAL_ACCESS_TOKEN , the job won't trigger another workflow. It's like using [skip ci] in other CI's. name : Bump version on : push : branches : - master jobs : bump-version : if : \"!startsWith(github.event.head_commit.message, 'bump:')\" runs-on : ubuntu-latest name : \"Bump version and create changelog with commitizen\" steps : - name : Check out uses : actions/checkout@v2 with : token : \"${{ secrets.PERSONAL_ACCESS_TOKEN }}\" fetch-depth : 0 - name : Create bump and changelog uses : commitizen-tools/commitizen-action@master with : github_token : ${{ secrets.PERSONAL_ACCESS_TOKEN }} Push to master and that's it. Creating a github release You can modify the previous action. Add the variable changelog_increment_filename in the commitizen-action , specifying where to output the content of the changelog for the newly created version. And then add a step using a github action to create the release: softprops/action-gh-release The commitizen action creates an env variable called REVISION , containing the newely created version. - name : Create bump and changelog uses : commitizen-tools/commitizen-action@master with : github_token : ${{ secrets.PERSONAL_ACCESS_TOKEN }} changelog_increment_filename : body.md - name : Release uses : softprops/action-gh-release@v1 with : body_path : \"body.md\" tag_name : ${{ env.REVISION }} env : GITHUB_TOKEN : ${{ secrets.GITHUB_TOKEN }} Publishing a python package Once the new tag is created, triggering an automatic publish command would be desired. In order to do so, the crendetial needs to be added with the information of our PyPI account. Instead of using username and password, we suggest using api token generated from PyPI. After generate api token, use the token as the PyPI password and __token__ as the username. Go to Settings > Secrets > Add new secret and add the secret: PYPI_PASSWORD . Create a file in .github/workflows/pythonpublish.yaml with the following content: name : Upload Python Package on : push : tags : - \"*\" # Will trigger for every tag, alternative: 'v*' jobs : deploy : runs-on : ubuntu-latest steps : - uses : actions/checkout@v1 - name : Set up Python uses : actions/setup-python@v1 with : python-version : \"3.x\" - name : Install dependencies run : | python -m pip install --pre -U poetry poetry --version poetry install - name : Build and publish env : PYPI_USERNAME : __token__ PYPI_PASSWORD : ${{ secrets.PYPI_PASSWORD }} run : | ./scripts/publish Notice that we are calling a bash script in ./scripts/publish , you should configure it with your tools (twine, poetry, etc.). Check commitizen example You can also use pypa/gh-action-pypi-publish to publish your package. Push the changes and that's it.","title":"Github Actions"},{"location":"tutorials/github_actions.html#create-a-new-release-with-github-actions","text":"","title":"Create a new release with Github Actions"},{"location":"tutorials/github_actions.html#automatic-bumping-of-version","text":"To execute cz bump in your CI, and push the new commit and the new tag, back to your master branch, we have to: Create a personal access token. Follow the instructions here . And copy the generated key Create a secret called PERSONAL_ACCESS_TOKEN , with the copied key, by going to your project repository and then Settings > Secrets > Add new secret . In your repository create a new file .github/workflows/bumpversion.yml with the following content. Warning If you use GITHUB_TOKEN instead of PERSONAL_ACCESS_TOKEN , the job won't trigger another workflow. It's like using [skip ci] in other CI's. name : Bump version on : push : branches : - master jobs : bump-version : if : \"!startsWith(github.event.head_commit.message, 'bump:')\" runs-on : ubuntu-latest name : \"Bump version and create changelog with commitizen\" steps : - name : Check out uses : actions/checkout@v2 with : token : \"${{ secrets.PERSONAL_ACCESS_TOKEN }}\" fetch-depth : 0 - name : Create bump and changelog uses : commitizen-tools/commitizen-action@master with : github_token : ${{ secrets.PERSONAL_ACCESS_TOKEN }} Push to master and that's it.","title":"Automatic bumping of version"},{"location":"tutorials/github_actions.html#creating-a-github-release","text":"You can modify the previous action. Add the variable changelog_increment_filename in the commitizen-action , specifying where to output the content of the changelog for the newly created version. And then add a step using a github action to create the release: softprops/action-gh-release The commitizen action creates an env variable called REVISION , containing the newely created version. - name : Create bump and changelog uses : commitizen-tools/commitizen-action@master with : github_token : ${{ secrets.PERSONAL_ACCESS_TOKEN }} changelog_increment_filename : body.md - name : Release uses : softprops/action-gh-release@v1 with : body_path : \"body.md\" tag_name : ${{ env.REVISION }} env : GITHUB_TOKEN : ${{ secrets.GITHUB_TOKEN }}","title":"Creating a github release"},{"location":"tutorials/github_actions.html#publishing-a-python-package","text":"Once the new tag is created, triggering an automatic publish command would be desired. In order to do so, the crendetial needs to be added with the information of our PyPI account. Instead of using username and password, we suggest using api token generated from PyPI. After generate api token, use the token as the PyPI password and __token__ as the username. Go to Settings > Secrets > Add new secret and add the secret: PYPI_PASSWORD . Create a file in .github/workflows/pythonpublish.yaml with the following content: name : Upload Python Package on : push : tags : - \"*\" # Will trigger for every tag, alternative: 'v*' jobs : deploy : runs-on : ubuntu-latest steps : - uses : actions/checkout@v1 - name : Set up Python uses : actions/setup-python@v1 with : python-version : \"3.x\" - name : Install dependencies run : | python -m pip install --pre -U poetry poetry --version poetry install - name : Build and publish env : PYPI_USERNAME : __token__ PYPI_PASSWORD : ${{ secrets.PYPI_PASSWORD }} run : | ./scripts/publish Notice that we are calling a bash script in ./scripts/publish , you should configure it with your tools (twine, poetry, etc.). Check commitizen example You can also use pypa/gh-action-pypi-publish to publish your package. Push the changes and that's it.","title":"Publishing a python package"},{"location":"tutorials/gitlab_ci.html","text":"Create a new release using GitLab CI For this example, we have a python/django application and Docker as a containerization tool. Goal : Bump a new version every time that a change occurs on the master branch. The bump should be executed automatically by the CI process. Development Workflow A developer creates a new commit on any branch (except master ) A developer creates a merge request (MR) against master branch When the MR is merged into master, the 2 stages of the CI are executed For simplification, we store the software version in a file called VERSION . You can use any file that you want as commitizen supports it. The commit message executed automatically by the CI must include [skip-ci] in the message; otherwise, the process will generate a loop. You can define the message structure in commitizen as well. Gitlab Configuration To be able to change files and push new changes with Gitlab CI runners, we need to have a ssh key and configure a git user. First, let's create a ssh key . The only requirement is to create it without a passphrase: ssh-keygen -f deploy_key -N \"\" The previous command will create a private and public key under the files deploy_key and deploy_key.pub . We will use them later. For the git user, we need an email and username. You can choose whatever you want; in this example, we choose ci-runner@myproject.com and admin , respectively. Now, we need to create three environment variables that will be visible for the runners. They should be created in the variables section under settings/ci_cd : Create SSH_PRIVATE_KEY , CI_EMAIL , CI_USERNAME variables, and fill them with the private_key , email and username that we have created previously. The latest step is to create a deploy key. To do this, we should create it under the section settings/repository and fill it with the public key generated before. Check Write access allowed ; otherwise, the runner won't be able to write the changes to the repository. If you have more projects under the same organization, you can reuse the deploy key created before, but you will have to repeat the step where we have created the environment variables (ssh key, email, and username). tip: If the CI raise some errors, try to unprotected the private key. Defining GitLab CI Pipeline Create a .gitlab-ci.yaml file that contains stages and jobs configurations. You can find more info here . Define stages and jobs . For this example, we define two stages with one job each one. Test the application. Auto bump the version. This means changing the file/s that reflects the version, creating a new commit and git tag. Stages and Jobs image : docker:latest services : - docker:dind variables : API_IMAGE_NAME : $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME before_script : - apk add --no-cache py-pip - pip install docker-compose stages : - test - auto-bump test : stage : test script : - docker-compose run -e DJANGO_ENVIRONMENT=dev your_project python manage.py test # run tests auto-bump : stage : auto-bump image : python:3.6 before_script : - \"which ssh-agent || ( apt-get update -qy && apt-get install openssh-client -qqy )\" - eval `ssh-agent -s` - echo \"${SSH_PRIVATE_KEY}\" | tr -d '\\r' | ssh-add - > /dev/null # add ssh key - pip3 install -U Commitizen # install commitizen - mkdir -p ~/.ssh - chmod 700 ~/.ssh - echo \"$SSH_PUBLIC_KEY\" >> ~/.ssh/id_rsa.pub - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config' dependencies : - test script : - git remote set-url origin git@gitlab.com:discover/rentee-core.git # git configuration - git config --global user.email \"${CI_EMAIL}\" && git config --global user.name \"${CI_USERNAME}\" - 'exists=`git show-ref refs/heads/master` && if [ -n \"$exists\" ]; then git branch -D master; fi' - git checkout -b master - cz bump # execute auto bump and push to master - git push origin master:$CI_COMMIT_REF_NAME - TAG=$(head -n 1 VERSION) # get the new software version and save into artifacts - echo \"#!/bin/sh\" >> variables - echo \"export TAG='$TAG'\" >> variables - git push origin $TAG only : refs : - master artifacts : paths : - variables So, every time that a developer push to any branch, the test job is executed. If the branch is master and the test jobs success, the auto-bump takes place. To be able to push using the Gitlab runner, we have to set the ssh key, configure git, and finally execute the auto bump. After merging the new changed into master, we have the final result:","title":"GitLab CI"},{"location":"tutorials/gitlab_ci.html#create-a-new-release-using-gitlab-ci","text":"For this example, we have a python/django application and Docker as a containerization tool. Goal : Bump a new version every time that a change occurs on the master branch. The bump should be executed automatically by the CI process.","title":"Create a new release using GitLab CI"},{"location":"tutorials/gitlab_ci.html#development-workflow","text":"A developer creates a new commit on any branch (except master ) A developer creates a merge request (MR) against master branch When the MR is merged into master, the 2 stages of the CI are executed For simplification, we store the software version in a file called VERSION . You can use any file that you want as commitizen supports it. The commit message executed automatically by the CI must include [skip-ci] in the message; otherwise, the process will generate a loop. You can define the message structure in commitizen as well.","title":"Development Workflow"},{"location":"tutorials/gitlab_ci.html#gitlab-configuration","text":"To be able to change files and push new changes with Gitlab CI runners, we need to have a ssh key and configure a git user. First, let's create a ssh key . The only requirement is to create it without a passphrase: ssh-keygen -f deploy_key -N \"\" The previous command will create a private and public key under the files deploy_key and deploy_key.pub . We will use them later. For the git user, we need an email and username. You can choose whatever you want; in this example, we choose ci-runner@myproject.com and admin , respectively. Now, we need to create three environment variables that will be visible for the runners. They should be created in the variables section under settings/ci_cd : Create SSH_PRIVATE_KEY , CI_EMAIL , CI_USERNAME variables, and fill them with the private_key , email and username that we have created previously. The latest step is to create a deploy key. To do this, we should create it under the section settings/repository and fill it with the public key generated before. Check Write access allowed ; otherwise, the runner won't be able to write the changes to the repository. If you have more projects under the same organization, you can reuse the deploy key created before, but you will have to repeat the step where we have created the environment variables (ssh key, email, and username). tip: If the CI raise some errors, try to unprotected the private key.","title":"Gitlab Configuration"},{"location":"tutorials/gitlab_ci.html#defining-gitlab-ci-pipeline","text":"Create a .gitlab-ci.yaml file that contains stages and jobs configurations. You can find more info here . Define stages and jobs . For this example, we define two stages with one job each one. Test the application. Auto bump the version. This means changing the file/s that reflects the version, creating a new commit and git tag.","title":"Defining GitLab CI Pipeline"},{"location":"tutorials/gitlab_ci.html#stages-and-jobs","text":"image : docker:latest services : - docker:dind variables : API_IMAGE_NAME : $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME before_script : - apk add --no-cache py-pip - pip install docker-compose stages : - test - auto-bump test : stage : test script : - docker-compose run -e DJANGO_ENVIRONMENT=dev your_project python manage.py test # run tests auto-bump : stage : auto-bump image : python:3.6 before_script : - \"which ssh-agent || ( apt-get update -qy && apt-get install openssh-client -qqy )\" - eval `ssh-agent -s` - echo \"${SSH_PRIVATE_KEY}\" | tr -d '\\r' | ssh-add - > /dev/null # add ssh key - pip3 install -U Commitizen # install commitizen - mkdir -p ~/.ssh - chmod 700 ~/.ssh - echo \"$SSH_PUBLIC_KEY\" >> ~/.ssh/id_rsa.pub - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config' dependencies : - test script : - git remote set-url origin git@gitlab.com:discover/rentee-core.git # git configuration - git config --global user.email \"${CI_EMAIL}\" && git config --global user.name \"${CI_USERNAME}\" - 'exists=`git show-ref refs/heads/master` && if [ -n \"$exists\" ]; then git branch -D master; fi' - git checkout -b master - cz bump # execute auto bump and push to master - git push origin master:$CI_COMMIT_REF_NAME - TAG=$(head -n 1 VERSION) # get the new software version and save into artifacts - echo \"#!/bin/sh\" >> variables - echo \"export TAG='$TAG'\" >> variables - git push origin $TAG only : refs : - master artifacts : paths : - variables So, every time that a developer push to any branch, the test job is executed. If the branch is master and the test jobs success, the auto-bump takes place. To be able to push using the Gitlab runner, we have to set the ssh key, configure git, and finally execute the auto bump. After merging the new changed into master, we have the final result:","title":"Stages and Jobs"},{"location":"tutorials/jenkins_pipeline.html","text":"Create a new release with Jenkins Pipelines For this we are using the modern approach of declarative pipelines . You must also ensure your jenkins instance supports docker. Most modern jenkins systems do have support for it, they have embraced it . pipeline { agent { any } environment { CI = 'true' } stages { stage ( 'Bump version' ) { when { beforeAgent true branch 'master' not { changelog '^bump:.+' } } steps { script { useCz { sh \"cz bump --changelog\" } // Here push back to your repository the new commit and tag } } } } } def useCz ( String authorName = 'Jenkins CI Server' , String authorEmail = 'your-jenkins@email.com' , String image = 'registry.hub.docker.com/commitizen/commitizen:latest' , Closure body ) { docker . image ( image ) . inside ( \"-u 0 -v $WORKSPACE:/workspace -w /workspace -e GIT_AUTHOR_NAME='${authorName}' -e GIT_AUTHOR_EMAIL='${authorEmail}'\" ) { sh \"git config --global user.email '${authorName}'\" sh \"git config --global user.name '${authorEmail}'\" body () } } Warning Using jenkins pipeline with any git plugin may require many different configurations, you'll have to tinker with it until your pipelines properly detects git events. Check your webhook in your git repository and check the \"behaviors\" and \"build strategies\" in your pipeline settings.","title":"Jenkins pipeline"},{"location":"tutorials/jenkins_pipeline.html#create-a-new-release-with-jenkins-pipelines","text":"For this we are using the modern approach of declarative pipelines . You must also ensure your jenkins instance supports docker. Most modern jenkins systems do have support for it, they have embraced it . pipeline { agent { any } environment { CI = 'true' } stages { stage ( 'Bump version' ) { when { beforeAgent true branch 'master' not { changelog '^bump:.+' } } steps { script { useCz { sh \"cz bump --changelog\" } // Here push back to your repository the new commit and tag } } } } } def useCz ( String authorName = 'Jenkins CI Server' , String authorEmail = 'your-jenkins@email.com' , String image = 'registry.hub.docker.com/commitizen/commitizen:latest' , Closure body ) { docker . image ( image ) . inside ( \"-u 0 -v $WORKSPACE:/workspace -w /workspace -e GIT_AUTHOR_NAME='${authorName}' -e GIT_AUTHOR_EMAIL='${authorEmail}'\" ) { sh \"git config --global user.email '${authorName}'\" sh \"git config --global user.name '${authorEmail}'\" body () } } Warning Using jenkins pipeline with any git plugin may require many different configurations, you'll have to tinker with it until your pipelines properly detects git events. Check your webhook in your git repository and check the \"behaviors\" and \"build strategies\" in your pipeline settings.","title":"Create a new release with Jenkins Pipelines"},{"location":"tutorials/writing_commits.html","text":"For this project to work well in your pipeline, a commit convention must be followed. By default commitizen uses the known conventional commits , but you can create your own following the docs information over customization . Conventional commits If you are using conventional commits , the most important thing to know is that you must begin your commits with at least one of these tags: fix , feat . And if you introduce a breaking change, then, you must add to your commit body the following BREAKING CHANGE . Using these 3 keywords will allow the proper identification of the semantic version. Of course, there are other keywords, but I'll leave it to the reader to explore them. Writing commits Not to the important part, when writing commits, it's important to think about: Your future self Your colleagues You may think this is trivial, but it's not. It's important for the reader to understand what happened. Recommendations Keep the message short : Makes the list of commits more readable (~50 chars). Talk imperative : Follow this rule: If applied, this commit will <commit message> Think about the CHANGELOG : Your commits will probably end up in the changelog so try writing for it, but also keep in mind that you can skip sending commits to the CHANGELOG by using different keywords (like build ). Use a commit per new feature : if you introduce multiple things related to the same commit, squash them. This is useful for auto-generating CHANGELOG. Do's Don'ts fix(commands): bump error when no user provided fix: stuff feat: add new commit command feat: commit command introduced","title":"Writing commits"},{"location":"tutorials/writing_commits.html#conventional-commits","text":"If you are using conventional commits , the most important thing to know is that you must begin your commits with at least one of these tags: fix , feat . And if you introduce a breaking change, then, you must add to your commit body the following BREAKING CHANGE . Using these 3 keywords will allow the proper identification of the semantic version. Of course, there are other keywords, but I'll leave it to the reader to explore them.","title":"Conventional commits"},{"location":"tutorials/writing_commits.html#writing-commits","text":"Not to the important part, when writing commits, it's important to think about: Your future self Your colleagues You may think this is trivial, but it's not. It's important for the reader to understand what happened.","title":"Writing commits"},{"location":"tutorials/writing_commits.html#recommendations","text":"Keep the message short : Makes the list of commits more readable (~50 chars). Talk imperative : Follow this rule: If applied, this commit will <commit message> Think about the CHANGELOG : Your commits will probably end up in the changelog so try writing for it, but also keep in mind that you can skip sending commits to the CHANGELOG by using different keywords (like build ). Use a commit per new feature : if you introduce multiple things related to the same commit, squash them. This is useful for auto-generating CHANGELOG. Do's Don'ts fix(commands): bump error when no user provided fix: stuff feat: add new commit command feat: commit command introduced","title":"Recommendations"}]}