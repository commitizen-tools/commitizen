{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Commitizen Documentation Site</p>"},{"location":"#about","title":"About","text":"<p>Commitizen is a powerful release management tool that helps teams maintain consistent and meaningful commit messages while automating version management.</p>"},{"location":"#what-commitizen-does","title":"What Commitizen Does","text":"<p>By enforcing standardized commit conventions (defaulting to Conventional Commits), Commitizen helps teams:</p> <ul> <li>Write clear, structured commit messages</li> <li>Automatically manage version numbers using semantic versioning</li> <li>Generate and maintain changelogs</li> <li>Streamline the release process</li> </ul>"},{"location":"#key-benefits","title":"Key Benefits","text":"<p>With just a simple <code>cz bump</code> command, Commitizen handles:</p> <ol> <li>Version Management: Automatically bumps version numbers and updates version files based on your commit history</li> <li>Changelog Generation: Creates and updates changelogs following the Keep a changelog format</li> <li>Commit Standardization: Enforces consistent commit message formats across your team</li> </ol> <p>This standardization makes your commit history more readable and meaningful, while the automation reduces manual work and potential errors in the release process.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Interactive CLI for standardized commits with default Conventional Commits support</li> <li>Intelligent version bumping using Semantic Versioning</li> <li>Automatic keep a changelog generation</li> <li>Built-in commit validation with pre-commit hooks</li> <li>Customizable commit rules and templates</li> <li>Multi-format version file support</li> <li>Custom rules and plugins via pip</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#requirements","title":"Requirements","text":"<p>Before installing Commitizen, ensure you have:</p> <ul> <li>Python <code>3.9+</code></li> <li>Git <code>1.8.5.2+</code></li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#global-installation-recommended","title":"Global Installation (Recommended)","text":"<p>The recommended way to install Commitizen is using <code>pipx</code> or <code>uv</code>, which ensures a clean, isolated installation: Using pipx: <pre><code># Install Commitizen\npipx install commitizen\n\n# Keep it updated\npipx upgrade commitizen\n</code></pre></p> <p>Using uv: <pre><code># Install commitizen\nuv tool install commitizen\n\n# Keep it updated\nuv tool upgrade commitizen\n</code></pre></p> <p>(For macOS users) Using Homebrew: <pre><code>brew install commitizen\n</code></pre></p>"},{"location":"#project-specific-installation","title":"Project-Specific Installation","text":"<p>You can add Commitizen to your Python project using any of these package managers:</p> <p>Using pip: <pre><code>pip install -U commitizen\n</code></pre></p> <p>Using conda: <pre><code>conda install -c conda-forge commitizen\n</code></pre></p> <p>Using Poetry: <pre><code># For Poetry &gt;= 1.2.0\npoetry add commitizen --group dev\n\n# For Poetry &lt; 1.2.0\npoetry add commitizen --dev\n</code></pre></p> <p>Using uv: <pre><code>uv add commitizen\n</code></pre></p> <p>Using pdm: <pre><code>pdm add -d commitizen\n</code></pre></p>"},{"location":"#basic-commands","title":"Basic Commands","text":""},{"location":"#initialize-commitizen","title":"Initialize Commitizen","text":"<p>To get started, you'll need to set up your configuration. You have two options:</p> <ol> <li> <p>Use the interactive setup: <pre><code>cz init\n</code></pre></p> </li> <li> <p>Manually create a configuration file (<code>.cz.toml</code> or <code>cz.toml</code>): <pre><code>[tool.commitizen]\nversion = \"0.1.0\"\nupdate_changelog_on_bump = true\n</code></pre></p> </li> </ol>"},{"location":"#create-commits","title":"Create Commits","text":"<p>Create standardized commits using: <pre><code>cz commit\n# or use the shortcut\ncz c\n</code></pre></p> <p>To sign off your commits: <pre><code>cz commit -- --signoff\n# or use the shortcut\ncz commit -- -s\n</code></pre></p> <p>For more commit options, run <code>cz commit --help</code>.</p>"},{"location":"#version-management","title":"Version Management","text":"<p>The most common command you'll use is: <pre><code>cz bump\n</code></pre></p> <p>This command:</p> <ul> <li>Bumps your project's version</li> <li>Creates a git tag</li> <li>Updates the changelog (if <code>update_changelog_on_bump</code> is enabled)</li> <li>Updates version files</li> </ul> <p>You can customize:</p> <ul> <li>Version files</li> <li>Version scheme</li> <li>Version provider</li> </ul> <p>For all available options, see the bump command documentation.</p>"},{"location":"#advanced-usage","title":"Advanced Usage","text":""},{"location":"#get-project-version","title":"Get Project Version","text":"<pre><code># Get your project's version (instead of Commitizen's version)\ncz version -p\n# Preview changelog changes\ncz changelog --dry-run \"$(cz version -p)\"\n</code></pre> <p>This command is particularly useful for automation scripts and CI/CD pipelines.</p> <p>For example, you can use the output of the command <code>cz changelog --dry-run \"$(cz version -p)\"</code> to notify your team about a new release in Slack.</p>"},{"location":"#pre-commit-integration","title":"Pre-commit Integration","text":"<p>Commitizen can automatically validate your commit messages using pre-commit hooks.</p> <ol> <li> <p>Add to your <code>.pre-commit-config.yaml</code>: <pre><code>---\nrepos:\n  - repo: https://github.com/commitizen-tools/commitizen\n    rev: master  # Replace with latest tag\n    hooks:\n      - id: commitizen\n      - id: commitizen-branch\n        stages: [pre-push]\n</code></pre></p> </li> <li> <p>Install the hooks: <pre><code>pre-commit install --hook-type commit-msg --hook-type pre-push\n</code></pre></p> </li> </ol> Hook Recommended Stage commitizen commit-msg commitizen-branch pre-push <p>Note: Replace <code>master</code> with the latest tag to avoid warnings. You can automatically update this with: <pre><code>pre-commit autoupdate\n</code></pre></p> <p>For more details about commit validation, see the check command documentation.</p>"},{"location":"#help-reference","title":"Help &amp; Reference","text":""},{"location":"#command-line-interface","title":"Command Line Interface","text":"<p>Commitizen provides a comprehensive CLI with various commands. Here's the complete reference:</p> <p></p>"},{"location":"#quick-reference","title":"Quick Reference","text":"Command Description Alias <code>cz init</code> Initialize Commitizen configuration - <code>cz commit</code> Create a new commit <code>cz c</code> <code>cz bump</code> Bump version and update changelog - <code>cz changelog</code> Generate changelog <code>cz ch</code> <code>cz check</code> Validate commit messages - <code>cz version</code> Show version information -"},{"location":"#additional-resources","title":"Additional Resources","text":"<ul> <li>Conventional Commits Specification</li> <li>Exit Codes Reference</li> <li>Configuration Guide</li> <li>Command Documentation</li> </ul>"},{"location":"#getting-help","title":"Getting Help","text":"<p>For each command, you can get detailed help by adding <code>--help</code>:</p> <pre><code>cz commit --help\ncz bump --help\ncz changelog --help\n</code></pre> <p>For more details, visit our documentation site.</p>"},{"location":"#setting-up-bash-completion","title":"Setting up bash completion","text":"<p>Commitizen supports command-line completion through argcomplete, which is automatically installed as a dependency. This feature provides intelligent auto-completion for all Commitizen commands and options.</p>"},{"location":"#supported-shells","title":"Supported Shells","text":"<ul> <li>Bash: Full support</li> <li>Zsh: Limited support</li> <li>Fish: Limited support</li> <li>Tcsh: Limited support</li> </ul>"},{"location":"#installation-methods","title":"Installation Methods","text":""},{"location":"#global-installation-recommended_1","title":"Global Installation (Recommended)","text":"<p>If you installed Commitizen globally (e.g., using <code>pipx</code> or <code>brew</code>), you can enable global completion:</p> <pre><code># Enable global completion for all Python applications\nsudo activate-global-python-argcomplete\n</code></pre>"},{"location":"#user-specific-installation","title":"User-Specific Installation","text":"<p>For a user-specific installation that persists across sessions:</p> <pre><code># Add to your shell's startup file (e.g., ~/.bashrc, ~/.zshrc)\nregister-python-argcomplete cz &gt;&gt; ~/.bashrc\n</code></pre>"},{"location":"#temporary-installation","title":"Temporary Installation","text":"<p>For one-time activation in your current shell session:</p> <pre><code># Activate completion for current session only\neval \"$(register-python-argcomplete cz)\"\n</code></pre>"},{"location":"#verification","title":"Verification","text":"<p>After installation, you can verify the completion is working by:</p> <ol> <li>Opening a new terminal session</li> <li>Typing <code>cz</code> followed by a space and pressing <code>TAB</code> twice</li> <li>You should see a list of available commands</li> </ol> <p>For more detailed information about argcomplete configuration and troubleshooting, visit the argcomplete documentation.</p>"},{"location":"#sponsors","title":"Sponsors","text":"<p>These are our cool sponsors!</p>"},{"location":"config/","title":"Configuration","text":""},{"location":"config/#settings","title":"Settings","text":""},{"location":"config/#name","title":"<code>name</code>","text":"<p>Type: <code>str</code></p> <p>Default: <code>\"cz_conventional_commits\"</code></p> <p>Name of the committing rules to use</p>"},{"location":"config/#version","title":"<code>version</code>","text":"<p>Type: <code>str</code></p> <p>Default: <code>None</code></p> <p>Current version. Example: \"0.1.2\". Required if you use <code>version_provider = \"commitizen\"</code>.</p>"},{"location":"config/#version_files","title":"<code>version_files</code>","text":"<p>Type: <code>list</code></p> <p>Default: <code>[ ]</code></p> <p>Files were the version will be updated. A pattern to match a line, can also be specified, separated by <code>:</code> Read more</p>"},{"location":"config/#version_provider","title":"<code>version_provider</code>","text":"<p>Type: <code>str</code></p> <p>Default: <code>commitizen</code></p> <p>Version provider used to read and write version Read more</p>"},{"location":"config/#version_scheme","title":"<code>version_scheme</code>","text":"<p>Type: <code>str</code></p> <p>Default: <code>pep440</code></p> <p>Select a version scheme from the following options [<code>pep440</code>, <code>semver</code>, <code>semver2</code>]. Useful for non-python projects. Read more</p>"},{"location":"config/#tag_format","title":"<code>tag_format</code>","text":"<p>Type: <code>str</code></p> <p>Default: <code>$version</code></p> <p>Format for the git tag, useful for old projects, that use a convention like <code>\"v1.2.1\"</code>. Read more</p>"},{"location":"config/#legacy_tag_formats","title":"<code>legacy_tag_formats</code>","text":"<p>Type: <code>list</code></p> <p>Default: <code>[ ]</code></p> <p>Legacy git tag formats, useful for old projects that changed tag format. Tags matching those formats will be recognized as version tags and be included in the changelog. Each entry uses the syntax as <code>tag_format</code>. Read more</p>"},{"location":"config/#ignored_tag_formats","title":"<code>ignored_tag_formats</code>","text":"<p>Type: <code>list</code></p> <p>Default: <code>[ ]</code></p> <p>Tags matching those formats will be totally ignored and won't raise a warning. Each entry uses the syntax as <code>tag_format</code> with the addition of <code>*</code> that will match everything (non-greedy). Read more</p>"},{"location":"config/#update_changelog_on_bump","title":"<code>update_changelog_on_bump</code>","text":"<p>Type: <code>bool</code></p> <p>Default: <code>false</code></p> <p>Create changelog when running <code>cz bump</code></p>"},{"location":"config/#gpg_sign","title":"<code>gpg_sign</code>","text":"<p>Type: <code>bool</code></p> <p>Default: <code>false</code></p> <p>Use gpg signed tags instead of lightweight tags.</p>"},{"location":"config/#annotated_tag","title":"<code>annotated_tag</code>","text":"<p>Type: <code>bool</code></p> <p>Default: <code>false</code></p> <p>Use annotated tags instead of lightweight tags. See difference</p>"},{"location":"config/#bump_message","title":"<code>bump_message</code>","text":"<p>Type: <code>str</code></p> <p>Default: <code>None</code></p> <p>Create custom commit message, useful to skip CI. Read more</p>"},{"location":"config/#retry_after_failure","title":"<code>retry_after_failure</code>","text":"<p>Type: <code>bool</code></p> <p>Default: <code>false</code></p> <p>Automatically retry failed commit when running <code>cz commit</code>. Read more</p>"},{"location":"config/#allow_abort","title":"<code>allow_abort</code>","text":"<p>Type: <code>bool</code></p> <p>Default: <code>false</code></p> <p>Disallow empty commit messages, useful in CI. Read more</p>"},{"location":"config/#allowed_prefixes","title":"<code>allowed_prefixes</code>","text":"<p>Type: <code>list</code> Default: <code>[ \"Merge\", \"Revert\", \"Pull request\", \"fixup!\", \"squash!\"]</code> Allow some prefixes and do not try to match the regex when checking the message Read more</p>"},{"location":"config/#changelog_file","title":"<code>changelog_file</code>","text":"<p>Type: <code>str</code></p> <p>Default: <code>CHANGELOG.md</code></p> <p>Filename of exported changelog</p>"},{"location":"config/#changelog_format","title":"<code>changelog_format</code>","text":"<p>Type: <code>str</code></p> <p>Default: None</p> <p>Format used to parse and generate the changelog, If not specified, guessed from <code>changelog_file</code>.</p>"},{"location":"config/#changelog_incremental","title":"<code>changelog_incremental</code>","text":"<p>Type: <code>bool</code></p> <p>Default: <code>false</code></p> <p>Update changelog with the missing versions. This is good if you don't want to replace previous versions in the file. Note: when doing <code>cz bump --changelog</code> this is automatically set to <code>true</code></p>"},{"location":"config/#changelog_start_rev","title":"<code>changelog_start_rev</code>","text":"<p>Type: <code>str</code></p> <p>Default: <code>None</code></p> <p>Start from a given git rev to generate the changelog</p>"},{"location":"config/#changelog_merge_prerelease","title":"<code>changelog_merge_prerelease</code>","text":"<p>Type: <code>bool</code></p> <p>Default: <code>false</code></p> <p>Collect all changes of prerelease versions into the next non-prerelease version when creating the changelog.</p>"},{"location":"config/#style","title":"<code>style</code>","text":"<p>Type: <code>list</code></p> <p>see above</p> <p>Style for the prompts (It will merge this value with default style.) See More (Styling your prompts with your favorite colors)</p>"},{"location":"config/#customize","title":"<code>customize</code>","text":"<p>Type: <code>dict</code></p> <p>Default: <code>None</code></p> <p>This is only supported when config through <code>toml</code>. Custom rules for committing and bumping. Read more</p>"},{"location":"config/#use_shortcuts","title":"<code>use_shortcuts</code>","text":"<p>Type: <code>bool</code></p> <p>Default: <code>false</code></p> <p>If enabled, Commitizen will show keyboard shortcuts when selecting from a list. Define a <code>key</code> for each of your choices to set the key. Read more</p>"},{"location":"config/#major_version_zero","title":"<code>major_version_zero</code>","text":"<p>Type: <code>bool</code></p> <p>Default: <code>false</code></p> <p>When true, breaking changes on a <code>0.x</code> will remain as a <code>0.x</code> version. On <code>false</code>, a breaking change will bump a <code>0.x</code> version to <code>1.0</code>. Read more</p>"},{"location":"config/#prerelease_offset","title":"<code>prerelease_offset</code>","text":"<p>Type: <code>int</code></p> <p>Default: <code>0</code></p> <p>In some circumstances, a prerelease cannot start with a 0, e.g. in an embedded project individual characters are encoded as bytes. This can be done by specifying an offset from which to start counting. Read more</p>"},{"location":"config/#pre_bump_hooks","title":"<code>pre_bump_hooks</code>","text":"<p>Type: <code>list[str]</code></p> <p>Default: <code>[]</code></p> <p>Calls the hook scripts before bumping version. Read more</p>"},{"location":"config/#post_bump_hooks","title":"<code>post_bump_hooks</code>","text":"<p>Type: <code>list[str]</code></p> <p>Default: <code>[]</code></p> <p>Calls the hook scripts after bumping the version. Read more</p>"},{"location":"config/#encoding","title":"<code>encoding</code>","text":"<p>Type: <code>str</code></p> <p>Default: <code>utf-8</code></p> <p>Sets the character encoding to be used when parsing commit messages. Read more</p>"},{"location":"config/#template","title":"<code>template</code>","text":"<p>Type: <code>str</code></p> <p>Default: <code>None</code> (provided by plugin)</p> <p>Provide custom changelog jinja template path relative to the current working directory. Read more</p>"},{"location":"config/#extras","title":"<code>extras</code>","text":"<p>Type: <code>dict[str, Any]</code></p> <p>Default: <code>{}</code></p> <p>Provide extra variables to the changelog template. Read more</p>"},{"location":"config/#configuration-file","title":"Configuration file","text":""},{"location":"config/#pyprojecttoml-cztoml-or-cztoml","title":"<code>pyproject.toml</code>, <code>.cz.toml</code> or <code>cz.toml</code>","text":"<p>Default and recommended configuration format for a project. For a python project, we recommend adding an entry to your <code>pyproject.toml</code>. You can also create a <code>.cz.toml</code> or <code>cz.toml</code> file at the root of your project folder.</p> <p>Example configuration:</p> <pre><code>[tool.commitizen]\nname = \"cz_conventional_commits\"\nversion = \"0.1.0\"\nversion_files = [\n    \"src/__version__.py\",\n    \"pyproject.toml:version\"\n]\nupdate_changelog_on_bump = true\nstyle = [\n    [\"qmark\", \"fg:#ff9d00 bold\"],\n    [\"question\", \"bold\"],\n    [\"answer\", \"fg:#ff9d00 bold\"],\n    [\"pointer\", \"fg:#ff9d00 bold\"],\n    [\"highlighted\", \"fg:#ff9d00 bold\"],\n    [\"selected\", \"fg:#cc5454\"],\n    [\"separator\", \"fg:#cc5454\"],\n    [\"instruction\", \"\"],\n    [\"text\", \"\"],\n    [\"disabled\", \"fg:#858585 italic\"]\n]\n</code></pre>"},{"location":"config/#czjson-or-czjson","title":"<code>.cz.json</code> or <code>cz.json</code>","text":"<p>Commitizen has support for JSON configuration. Recommended for <code>NodeJS</code> projects.</p> <pre><code>{\n  \"commitizen\": {\n    \"name\": \"cz_conventional_commits\",\n    \"version\": \"0.1.0\",\n    \"version_files\": [\"src/__version__.py\", \"pyproject.toml:version\"],\n    \"style\": [\n      [\"qmark\", \"fg:#ff9d00 bold\"],\n      [\"question\", \"bold\"],\n      [\"answer\", \"fg:#ff9d00 bold\"],\n      [\"pointer\", \"fg:#ff9d00 bold\"],\n      [\"highlighted\", \"fg:#ff9d00 bold\"],\n      [\"selected\", \"fg:#cc5454\"],\n      [\"separator\", \"fg:#cc5454\"],\n      [\"instruction\", \"\"],\n      [\"text\", \"\"],\n      [\"disabled\", \"fg:#858585 italic\"]\n    ]\n  }\n}\n</code></pre>"},{"location":"config/#czyaml-or-czyaml","title":"<code>.cz.yaml</code> or <code>cz.yaml</code>","text":"<p>YAML configuration is supported by Commitizen. Recommended for <code>Go</code>, <code>ansible</code>, or even <code>helm</code> charts projects.</p> <pre><code>commitizen:\n  name: cz_conventional_commits\n  version: 0.1.0\n  version_files:\n    - src/__version__.py\n    - pyproject.toml:version\n  style:\n    - - qmark\n      - fg:#ff9d00 bold\n    - - question\n      - bold\n    - - answer\n      - fg:#ff9d00 bold\n    - - pointer\n      - fg:#ff9d00 bold\n    - - highlighted\n      - fg:#ff9d00 bold\n    - - selected\n      - fg:#cc5454\n    - - separator\n      - fg:#cc5454\n    - - instruction\n      - \"\"\n    - - text\n      - \"\"\n    - - disabled\n      - fg:#858585 italic\n</code></pre>"},{"location":"config/#version-providers","title":"Version providers","text":"<p>Commitizen can read and write version from different sources. By default, it uses the <code>commitizen</code> one which is using the <code>version</code> field from the Commitizen settings. But you can use any <code>commitizen.provider</code> entrypoint as value for <code>version_provider</code>.</p> <p>Commitizen provides some version providers for some well known formats:</p> name description <code>commitizen</code> Default version provider: Fetch and set version in Commitizen config. <code>scm</code> Fetch the version from git and does not need to set it back <code>pep621</code> Get and set version from <code>pyproject.toml</code> <code>project.version</code> field <code>poetry</code> Get and set version from <code>pyproject.toml</code> <code>tool.poetry.version</code> field <code>uv</code> Get and set version from <code>pyproject.toml</code> <code>project.version</code> field and <code>uv.lock</code> <code>package.version</code> field whose <code>package.name</code> field is the same as <code>pyproject.toml</code> <code>project.name</code> field <code>cargo</code> Get and set version from <code>Cargo.toml</code> <code>package.version</code> field and <code>Cargo.lock</code> <code>package.version</code> field whose <code>package.name</code> field is the same as <code>Cargo.toml</code> <code>package.name</code> field <code>npm</code> Get and set version from <code>package.json</code> <code>version</code> field, <code>package-lock.json</code> <code>version,packages.''.version</code> fields if the file exists, and <code>npm-shrinkwrap.json</code> <code>version,packages.''.version</code> fields if the file exists <code>composer</code> Get and set version from <code>composer.json</code> <code>project.version</code> field <p>Note</p> <p>The <code>scm</code> provider is meant to be used with <code>setuptools-scm</code> or any packager <code>*-scm</code> plugin.</p> <p>An example in your <code>.cz.toml</code> or <code>cz.toml</code> would look like this:</p> <pre><code>[tool.commitizen]\nversion_provider = \"pep621\"\n</code></pre>"},{"location":"config/#custom-version-provider","title":"Custom version provider","text":"<p>You can add your own version provider by extending <code>VersionProvider</code> and exposing it on the <code>commitizen.provider</code> entrypoint.</p> <p>Here is a quick example of a <code>my-provider</code> provider reading and writing version in a <code>VERSION</code> file.</p> my_provider.py<pre><code>from pathlib import Path\nfrom commitizen.providers import VersionProvider\n\n\nclass MyProvider(VersionProvider):\n    file = Path() / \"VERSION\"\n\n    def get_version(self) -&gt; str:\n        return self.file.read_text()\n\n    def set_version(self, version: str):\n        self.file.write_text(version)\n</code></pre> setup.py<pre><code>from setuptools import setup\n\nsetup(\n    name=\"my-commitizen-provider\",\n    version=\"0.1.0\",\n    py_modules=[\"my_provider\"],\n    install_requires=[\"commitizen\"],\n    entry_points={\n        \"commitizen.provider\": [\n            \"my-provider = my_provider:MyProvider\",\n        ]\n    },\n)\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-to-commitizen","title":"Contributing to commitizen","text":"<p>First, thank you for taking the time to contribute! \ud83c\udf89</p> <p>When contributing to commitizen, please first create an issue to discuss the change you wish to make before making a change.</p> <p>If you're a first-time contributor, you can check the issues with the good first issue tag.</p>"},{"location":"contributing/#prerequisites-setup","title":"Prerequisites &amp; Setup","text":""},{"location":"contributing/#required-tools","title":"Required Tools","text":"<ol> <li>Python Environment<ul> <li>Python <code>&gt;=3.9</code></li> <li>Poetry <code>&gt;=2.0.0</code></li> </ul> </li> <li>Version Control &amp; Security<ul> <li>Git</li> <li>Commitizen</li> <li>GPG for commit signing<ul> <li>Installation page</li> <li>For Mac users: <code>brew install gnupg</code></li> <li>For Windows users: Download from Gpg4win</li> <li>For Linux users: Use your distribution's package manager (e.g., <code>apt install gnupg</code> for Ubuntu)</li> </ul> </li> </ul> </li> </ol>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork Commitizen</li> <li>Clone your fork:     <pre><code>git clone https://github.com/YOUR_USERNAME/commitizen.git\ncd commitizen\n</code></pre></li> <li>Add the upstream repository:     <pre><code>git remote add upstream https://github.com/commitizen-tools/commitizen.git\n</code></pre></li> <li>Set up the development environment:     <pre><code>poetry install\n</code></pre></li> <li>Set up pre-commit hooks:     <pre><code>poetry setup-pre-commit\n</code></pre></li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":"<ol> <li>Create a New Branch <pre><code>git switch -c feature/your-feature-name\n# or\ngit switch -c fix/your-bug-fix\n</code></pre></li> <li>Make Your Changes<ul> <li>Write your code</li> <li>Add tests for new functionalities or fixes</li> <li>Update documentation if needed</li> <li>Follow the existing code style</li> </ul> </li> <li>Testing<ul> <li>Run the full test suite: <code>poetry all</code></li> <li>Ensure test coverage doesn't drop (we use CodeCov)</li> <li>For documentation changes, run <code>poetry doc</code> to check for warnings/errors</li> </ul> </li> <li>Committing Changes<ul> <li>Use Commitizen to make commits (we follow conventional commits)</li> <li>Example: <code>cz commit</code></li> </ul> </li> <li>Documentation<ul> <li>Update <code>docs/README.md</code> if needed</li> <li>For CLI help screenshots: <code>poetry doc:screenshots</code></li> <li>DO NOT update <code>CHANGELOG.md</code> (automatically generated)</li> <li>DO NOT update version numbers (automatically handled)</li> </ul> </li> <li>Pull Request<ul> <li>Push your changes: <code>git push origin your-branch-name</code></li> <li>Create a pull request on GitHub</li> <li>Ensure CI checks pass</li> <li>Wait for review and address any feedback</li> </ul> </li> </ol>"},{"location":"contributing/#use-of-github-labels","title":"Use of GitHub Labels","text":"<ul> <li>good-first-issue (issue only)</li> <li>help-wanted</li> <li>issue-status: needs-triage (issue only) (default label for issues)</li> <li>issue-status: wont-fix</li> <li>issue-status: wont-implement</li> <li>issue-status: duplicate</li> <li>issue-status: invalid</li> <li>issue-status: wait-for-response</li> <li>issue-status: wait-for-implementation</li> <li>issue-status: pr-created</li> <li>pr-status: wait-for-review (default label for PRs)</li> <li>pr-status: reviewing</li> <li>pr-status: wait-for-modification</li> <li>pr-status: wait-for-response</li> <li>pr-status: ready-to-merge</li> <li>needs: test-case (PR only)</li> <li>needs: documentation (PR only)</li> <li>type: feature</li> <li>type: bug</li> <li>type: documentation</li> <li>type: refactor</li> <li>type: question (issue only)</li> <li>os: Windows</li> <li>os: Linux</li> <li>os: macOS</li> </ul>"},{"location":"contributing/#issue-life-cycle","title":"Issue life cycle","text":"<pre><code>graph TD\n    input[/issue created/] --&gt;\n    needs-triage\n    needs-triage --triage--&gt; close(wont-implement, wont-fix, duplicate, invalid)\n\n    needs-triage --triage--&gt; wait-for-implementation\n    needs-triage --triage--&gt; wait-for-response\n\n    wait-for-response --response--&gt; needs-triage\n\n    wait-for-implementation --PR-created--&gt; pr-created --PR-merged--&gt; output[/close/]\n\n    close --&gt; output[/close/]</code></pre>"},{"location":"contributing/#pull-request-life-cycle","title":"Pull request life cycle","text":"<pre><code>flowchart TD\n    input[/pull request created/] --&gt;\n    wait-for-review\n    --start reviewing --&gt;\n    reviewing\n    --finish review --&gt;\n    reviewed{approved}\n\n    reviewed --Y--&gt;\n    wait-for-merge --&gt;\n    output[/merge/]\n\n    reviewed --n--&gt;\n    require-more-information{require more information}\n\n    require-more-information --y--&gt;\n    wait-for-response\n    --response--&gt;\n    require-more-information\n\n    require-more-information --n--&gt;\n    wait-for-modification\n    --modification-received--&gt;\n    review</code></pre>"},{"location":"customization/","title":"Customization","text":"<p>Customizing Commitizen is not hard at all. We have two different ways to do so.</p>"},{"location":"customization/#1-customize-in-configuration-file","title":"1. Customize in configuration file","text":"<p>The basic steps are:</p> <ol> <li>Define your custom committing or bumping rules in the configuration file.</li> <li>Declare <code>name = \"cz_customize\"</code> in your configuration file, or add <code>-n cz_customize</code> when running Commitizen.</li> </ol> <p>Example:</p> <pre><code>[tool.commitizen]\nname = \"cz_customize\"\n\n[tool.commitizen.customize]\nmessage_template = \"{{change_type}}:{% if show_message %} {{message}}{% endif %}\"\nexample = \"feature: this feature enable customize through config file\"\nschema = \"&lt;type&gt;: &lt;body&gt;\"\nschema_pattern = \"(feature|bug fix):(\\\\s.*)\"\nbump_pattern = \"^(break|new|fix|hotfix)\"\nbump_map = {\"break\" = \"MAJOR\", \"new\" = \"MINOR\", \"fix\" = \"PATCH\", \"hotfix\" = \"PATCH\"}\nchange_type_order = [\"BREAKING CHANGE\", \"feat\", \"fix\", \"refactor\", \"perf\"]\ninfo_path = \"cz_customize_info.txt\"\ninfo = \"\"\"\nThis is customized info\n\"\"\"\ncommit_parser = \"^(?P&lt;change_type&gt;feature|bug fix):\\\\s(?P&lt;message&gt;.*)?\"\nchangelog_pattern = \"^(feature|bug fix)?(!)?\"\nchange_type_map = {\"feature\" = \"Feat\", \"bug fix\" = \"Fix\"}\n\n[[tool.commitizen.customize.questions]]\ntype = \"list\"\nname = \"change_type\"\nchoices = [{value = \"feature\", name = \"feature: A new feature.\"}, {value = \"bug fix\", name = \"bug fix: A bug fix.\"}]\n# choices = [\"feature\", \"fix\"]  # short version\nmessage = \"Select the type of change you are committing\"\n\n[[tool.commitizen.customize.questions]]\ntype = \"input\"\nname = \"message\"\nmessage = \"Body.\"\n\n[[tool.commitizen.customize.questions]]\ntype = \"confirm\"\nname = \"show_message\"\nmessage = \"Do you want to add body message in commit?\"\n</code></pre> <p>The equivalent example for a json config file:</p> <pre><code>{\n    \"commitizen\": {\n        \"name\": \"cz_customize\",\n        \"customize\": {\n            \"message_template\": \"{{change_type}}:{% if show_message %} {{message}}{% endif %}\",\n            \"example\": \"feature: this feature enable customize through config file\",\n            \"schema\": \"&lt;type&gt;: &lt;body&gt;\",\n            \"schema_pattern\": \"(feature|bug fix):(\\\\s.*)\",\n            \"bump_pattern\": \"^(break|new|fix|hotfix)\",\n            \"bump_map\": {\n                \"break\": \"MAJOR\",\n                \"new\": \"MINOR\",\n                \"fix\": \"PATCH\",\n                \"hotfix\": \"PATCH\"\n            },\n            \"change_type_order\": [\"BREAKING CHANGE\", \"feat\", \"fix\", \"refactor\", \"perf\"],\n            \"info_path\": \"cz_customize_info.txt\",\n            \"info\": \"This is customized info\",\n            \"commit_parser\": \"^(?P&lt;change_type&gt;feature|bug fix):\\\\s(?P&lt;message&gt;.*)?\",\n            \"changelog_pattern\": \"^(feature|bug fix)?(!)?\",\n            \"change_type_map\": {\"feature\": \"Feat\", \"bug fix\": \"Fix\"},\n            \"questions\": [\n                {\n                    \"type\": \"list\",\n                    \"name\": \"change_type\",\n                    \"choices\": [\n                        {\n                            \"value\": \"feature\",\n                            \"name\": \"feature: A new feature.\"\n                        },\n                        {\n                            \"value\": \"bug fix\",\n                            \"name\": \"bug fix: A bug fix.\"\n                        }\n                    ],\n                    \"message\": \"Select the type of change you are committing\"\n                },\n                {\n                    \"type\": \"input\",\n                    \"name\": \"message\",\n                    \"message\": \"Body.\"\n                },\n                {\n                    \"type\": \"confirm\",\n                    \"name\": \"show_message\",\n                    \"message\": \"Do you want to add body message in commit?\"\n                }\n            ]\n        }\n    }\n}\n</code></pre> <p>And the correspondent example for a yaml file:</p> <pre><code>commitizen:\n  name: cz_customize\n  customize:\n    message_template: \"{{change_type}}:{% if show_message %} {{message}}{% endif %}\"\n    example: 'feature: this feature enable customize through config file'\n    schema: \"&lt;type&gt;: &lt;body&gt;\"\n    schema_pattern: \"(feature|bug fix):(\\\\s.*)\"\n    bump_pattern: \"^(break|new|fix|hotfix)\"\n    commit_parser: \"^(?P&lt;change_type&gt;feature|bug fix):\\\\s(?P&lt;message&gt;.*)?\"\n    changelog_pattern: \"^(feature|bug fix)?(!)?\"\n    change_type_map:\n      feature: Feat\n      bug fix: Fix\n    bump_map:\n      break: MAJOR\n      new: MINOR\n      fix: PATCH\n      hotfix: PATCH\n    change_type_order: [\"BREAKING CHANGE\", \"feat\", \"fix\", \"refactor\", \"perf\"]\n    info_path: cz_customize_info.txt\n    info: This is customized info\n    questions:\n    - type: list\n      name: change_type\n      choices:\n      - value: feature\n        name: 'feature: A new feature.'\n      - value: bug fix\n        name: 'bug fix: A bug fix.'\n      message: Select the type of change you are committing\n    - type: input\n      name: message\n      message: 'Body.'\n    - type: confirm\n      name: show_message\n      message: 'Do you want to add body message in commit?'\n</code></pre>"},{"location":"customization/#customize-configuration","title":"Customize configuration","text":"Parameter Type Default Description <code>questions</code> <code>Questions</code> <code>None</code> Questions regarding the commit message. Detailed below. The type <code>Questions</code> is an alias to <code>Iterable[MutableMapping[str, Any]]</code> which is defined in <code>commitizen.defaults</code>. It expects a list of dictionaries. <code>message_template</code> <code>str</code> <code>None</code> The template for generating message from the given answers. <code>message_template</code> should either follow Jinja2 formatting specification, and all the variables in this template should be defined in <code>name</code> in <code>questions</code> <code>example</code> <code>str</code> <code>\"\"</code> (OPTIONAL) Provide an example to help understand the style. Used by <code>cz example</code>. <code>schema</code> <code>str</code> <code>\"\"</code> (OPTIONAL) Show the schema used. Used by <code>cz schema</code>. <code>schema_pattern</code> <code>str</code> <code>\"\"</code> (OPTIONAL) The regular expression used to do commit message validation. Used by <code>cz check</code>. <code>info_path</code> <code>str</code> <code>\"\"</code> (OPTIONAL) The path to the file that contains explanation of the commit rules. Used by <code>cz info</code>. If not provided <code>cz info</code>, will load <code>info</code> instead. <code>info</code> <code>str</code> <code>\"\"</code> (OPTIONAL) Explanation of the commit rules. Used by <code>cz info</code>. <code>bump_map</code> <code>dict</code> <code>None</code> (OPTIONAL) Dictionary mapping the extracted information to a <code>SemVer</code> increment type (<code>MAJOR</code>, <code>MINOR</code>, <code>PATCH</code>) <code>bump_pattern</code> <code>str</code> <code>None</code> (OPTIONAL) Regex to extract information from commit (subject and body) <code>change_type_order</code> <code>str</code> <code>None</code> (OPTIONAL) List of strings used to order the Changelog. All other types will be sorted alphabetically. Default is <code>[\"BREAKING CHANGE\", \"Feat\", \"Fix\", \"Refactor\", \"Perf\"]</code> <code>commit_parser</code> <code>str</code> <code>None</code> (OPTIONAL) Regex to extract information used in creating changelog. See more <code>changelog_pattern</code> <code>str</code> <code>None</code> (OPTIONAL) Regex to understand which commits to include in the changelog <code>change_type_map</code> <code>dict</code> <code>None</code> (OPTIONAL) Dictionary mapping the type of the commit to a changelog entry"},{"location":"customization/#detailed-questions-content","title":"Detailed <code>questions</code> content","text":"Parameter Type Default Description <code>type</code> <code>str</code> <code>None</code> The type of questions. Valid types: <code>list</code>, <code>select</code>, <code>input</code>, etc. The <code>select</code> type provides an interactive searchable list interface. See More <code>name</code> <code>str</code> <code>None</code> The key for the value answered by user. It's used in <code>message_template</code> <code>message</code> <code>str</code> <code>None</code> Detail description for the question. <code>choices</code> <code>list</code> <code>None</code> (OPTIONAL) The choices when <code>type = list</code> or <code>type = select</code>. Either use a list of values or a list of dictionaries with <code>name</code> and <code>value</code> keys. Keyboard shortcuts can be defined via <code>key</code>. See examples above. <code>default</code> <code>Any</code> <code>None</code> (OPTIONAL) The default value for this question. <code>filter</code> <code>str</code> <code>None</code> (OPTIONAL) Validator for user's answer. (Work in Progress) <code>multiline</code> <code>bool</code> <code>False</code> (OPTIONAL) Enable multiline support when <code>type = input</code>. <code>use_search_filter</code> <code>bool</code> <code>False</code> (OPTIONAL) Enable search/filter functionality for list/select type questions. This allows users to type and filter through the choices. <code>use_jk_keys</code> <code>bool</code> <code>True</code> (OPTIONAL) Enable/disable j/k keys for navigation in list/select type questions. Set to false if you prefer arrow keys only."},{"location":"customization/#shortcut-keys","title":"Shortcut keys","text":"<p>When the <code>use_shortcuts</code> config option is enabled, Commitizen can show and use keyboard shortcuts to select items from lists directly. For example, when using the <code>cz_conventional_commits</code> Commitizen template, shortcut keys are shown when selecting the commit type. Unless otherwise defined, keyboard shortcuts will be numbered automatically. To specify keyboard shortcuts for your custom choices, provide the shortcut using the <code>key</code> parameter in dictionary form for each choice you would like to customize.</p>"},{"location":"customization/#2-customize-through-customizing-a-class","title":"2. Customize through customizing a class","text":"<p>The basic steps are:</p> <ol> <li>Inheriting from <code>BaseCommitizen</code>.</li> <li>Give a name to your rules.</li> <li>Create a python package using <code>setup.py</code>, <code>poetry</code>, etc.</li> <li>Expose the class as a <code>commitizen.plugin</code> entrypoint.</li> </ol> <p>Check an example on how to configure <code>BaseCommitizen</code>.</p> <p>You can also automate the steps above through cookiecutter.</p> <pre><code>cookiecutter gh:commitizen-tools/commitizen_cz_template\n</code></pre> <p>See commitizen_cz_template for details.</p> <p>Once you publish your rules, you can send us a PR to the Third-party section.</p>"},{"location":"customization/#custom-commit-rules","title":"Custom commit rules","text":"<p>Create a Python module, for example <code>cz_jira.py</code>.</p> <p>Inherit from <code>BaseCommitizen</code>, and you must define <code>questions</code> and <code>message</code>. The others are optional.</p> <pre><code>from commitizen.cz.base import BaseCommitizen\nfrom commitizen.defaults import Questions\n\n\nclass JiraCz(BaseCommitizen):\n    # Questions = Iterable[MutableMapping[str, Any]]\n    # It expects a list with dictionaries.\n    def questions(self) -&gt; Questions:\n        \"\"\"Questions regarding the commit message.\"\"\"\n        questions = [\n            {\"type\": \"input\", \"name\": \"title\", \"message\": \"Commit title\"},\n            {\"type\": \"input\", \"name\": \"issue\", \"message\": \"Jira Issue number:\"},\n        ]\n        return questions\n\n    def message(self, answers: dict) -&gt; str:\n        \"\"\"Generate the message with the given answers.\"\"\"\n        return \"{0} (#{1})\".format(answers[\"title\"], answers[\"issue\"])\n\n    def example(self) -&gt; str:\n        \"\"\"Provide an example to help understand the style (OPTIONAL)\n\n        Used by `cz example`.\n        \"\"\"\n        return \"Problem with user (#321)\"\n\n    def schema(self) -&gt; str:\n        \"\"\"Show the schema used (OPTIONAL)\n\n        Used by `cz schema`.\n        \"\"\"\n        return \"&lt;title&gt; (&lt;issue&gt;)\"\n\n    def info(self) -&gt; str:\n        \"\"\"Explanation of the commit rules. (OPTIONAL)\n\n        Used by `cz info`.\n        \"\"\"\n        return \"We use this because is useful\"\n</code></pre> <p>The next file required is <code>setup.py</code> modified from flask version.</p> <pre><code>from setuptools import setup\n\nsetup(\n    name=\"JiraCommitizen\",\n    version=\"0.1.0\",\n    py_modules=[\"cz_jira\"],\n    license=\"MIT\",\n    long_description=\"this is a long description\",\n    install_requires=[\"commitizen\"],\n    entry_points={\"commitizen.plugin\": [\"cz_jira = cz_jira:JiraCz\"]},\n)\n</code></pre> <p>So in the end, we would have</p> <pre><code>.\n\u251c\u2500\u2500 cz_jira.py\n\u2514\u2500\u2500 setup.py\n</code></pre> <p>And that's it. You can install it without uploading to pypi by simply doing <code>pip install .</code></p> <p>If you feel like it should be part of this repo, create a PR.</p>"},{"location":"customization/#custom-bump-rules","title":"Custom bump rules","text":"<p>You need to define 2 parameters inside your custom <code>BaseCommitizen</code>.</p> Parameter Type Default Description <code>bump_pattern</code> <code>str</code> <code>None</code> Regex to extract information from commit (subject and body) <code>bump_map</code> <code>dict</code> <code>None</code> Dictionary mapping the extracted information to a <code>SemVer</code> increment type (<code>MAJOR</code>, <code>MINOR</code>, <code>PATCH</code>) <p>Let's see an example.</p> <pre><code>from commitizen.cz.base import BaseCommitizen\n\n\nclass StrangeCommitizen(BaseCommitizen):\n    bump_pattern = r\"^(break|new|fix|hotfix)\"\n    bump_map = {\"break\": \"MAJOR\", \"new\": \"MINOR\", \"fix\": \"PATCH\", \"hotfix\": \"PATCH\"}\n</code></pre> <p>That's it, your Commitizen now supports custom rules, and you can run.</p> <pre><code>cz -n cz_strange bump\n</code></pre>"},{"location":"customization/#custom-changelog-generator","title":"Custom changelog generator","text":"<p>The changelog generator should just work in a very basic manner without touching anything. You can customize it of course, and this are the variables you need to add to your custom <code>BaseCommitizen</code>.</p> Parameter Type Required Description <code>commit_parser</code> <code>str</code> NO Regex which should provide the variables explained in the changelog description <code>changelog_pattern</code> <code>str</code> NO Regex to validate the commits, this is useful to skip commits that don't meet your ruling standards like a Merge. Usually the same as bump_pattern <code>change_type_map</code> <code>dict</code> NO Convert the title of the change type that will appear in the changelog, if a value is not found, the original will be provided <code>changelog_message_builder_hook</code> <code>method: (dict, git.GitCommit) -&gt; dict | list | None</code> NO Customize with extra information your message output, like adding links, this function is executed per parsed commit. Each GitCommit contains the following attrs: <code>rev</code>, <code>title</code>, <code>body</code>, <code>author</code>, <code>author_email</code>. Returning a falsy value ignore the commit. <code>changelog_hook</code> <code>method: (full_changelog: str, partial_changelog: Optional[str]) -&gt; str</code> NO Receives the whole and partial (if used incremental) changelog. Useful to send slack messages or notify a compliance department. Must return the full_changelog <code>changelog_release_hook</code> <code>method: (release: dict, tag: git.GitTag) -&gt; dict</code> NO Receives each generated changelog release and its associated tag. Useful to enrich releases before they are rendered. Must return the update release <pre><code>from commitizen.cz.base import BaseCommitizen\nimport chat\nimport compliance\n\n\nclass StrangeCommitizen(BaseCommitizen):\n    changelog_pattern = r\"^(break|new|fix|hotfix)\"\n    commit_parser = r\"^(?P&lt;change_type&gt;feat|fix|refactor|perf|BREAKING CHANGE)(?:\\((?P&lt;scope&gt;[^()\\r\\n]*)\\)|\\()?(?P&lt;breaking&gt;!)?:\\s(?P&lt;message&gt;.*)?\"\n    change_type_map = {\n        \"feat\": \"Features\",\n        \"fix\": \"Bug Fixes\",\n        \"refactor\": \"Code Refactor\",\n        \"perf\": \"Performance improvements\",\n    }\n\n    def changelog_message_builder_hook(\n        self, parsed_message: dict, commit: git.GitCommit\n    ) -&gt; dict | list | None:\n        rev = commit.rev\n        m = parsed_message[\"message\"]\n        parsed_message[\n            \"message\"\n        ] = f\"{m} {rev} [{commit.author}]({commit.author_email})\"\n        return parsed_message\n\n    def changelog_release_hook(self, release: dict, tag: git.GitTag) -&gt; dict:\n        release[\"author\"] = tag.author\n        return release\n\n    def changelog_hook(\n        self, full_changelog: str, partial_changelog: Optional[str]\n    ) -&gt; str:\n        \"\"\"Executed at the end of the changelog generation\n\n        full_changelog: it's the output about to being written into the file\n        partial_changelog: it's the new stuff, this is useful to send slack messages or\n                           similar\n\n        Return:\n            the new updated full_changelog\n        \"\"\"\n        if partial_changelog:\n            chat.room(\"#committers\").notify(partial_changelog)\n        if full_changelog:\n            compliance.send(full_changelog)\n        full_changelog.replace(\" fix \", \" **fix** \")\n        return full_changelog\n</code></pre>"},{"location":"customization/#raise-customize-exception","title":"Raise Customize Exception","text":"<p>If you want <code>commitizen</code> to catch your exception and print the message, you'll have to inherit <code>CzException</code>.</p> <pre><code>from commitizen.cz.exception import CzException\n\n\nclass NoSubjectProvidedException(CzException):\n    ...\n</code></pre>"},{"location":"customization/#migrating-from-legacy-plugin-format","title":"Migrating from legacy plugin format","text":"<p>Commitizen migrated to a new plugin format relying on <code>importlib.metadata.EntryPoint</code>. Migration should be straight-forward for legacy plugins:</p> <ul> <li>Remove the <code>discover_this</code> line from your plugin module</li> <li>Expose the plugin class under as a <code>commitizen.plugin</code> entrypoint.</li> </ul> <p>The name of the plugin is now determined by the name of the entrypoint.</p>"},{"location":"customization/#example","title":"Example","text":"<p>If you were having a <code>CzPlugin</code> class in a <code>cz_plugin.py</code> module like this:</p> <pre><code>from commitizen.cz.base import BaseCommitizen\n\n\nclass PluginCz(BaseCommitizen):\n    ...\n\n\ndiscover_this = PluginCz\n</code></pre> <p>Then remove the <code>discover_this</code> line:</p> <pre><code>from commitizen.cz.base import BaseCommitizen\n\n\nclass PluginCz(BaseCommitizen):\n    ...\n</code></pre> <p>and expose the class as entrypoint in you setuptools:</p> <pre><code>from setuptools import setup\n\nsetup(\n    name=\"MyPlugin\",\n    version=\"0.1.0\",\n    py_modules=[\"cz_plugin\"],\n    entry_points={\"commitizen.plugin\": [\"plugin = cz_plugin:PluginCz\"]},\n    ...,\n)\n</code></pre> <p>Then your plugin will be available under the name <code>plugin</code>.</p>"},{"location":"customization/#customizing-the-changelog-template","title":"Customizing the changelog template","text":"<p>Commitizen gives you the possibility to provide your own changelog template, by:</p> <ul> <li>providing one with your customization class</li> <li>providing one from the current working directory and setting it:</li> <li>as configuration</li> <li>as <code>--template</code> parameter to both <code>bump</code> and <code>changelog</code> commands</li> <li>either by providing a template with the same name as the default template</li> </ul> <p>By default, the template used is the <code>CHANGELOG.md.j2</code> file from the Commitizen repository.</p>"},{"location":"customization/#providing-a-template-with-your-customization-class","title":"Providing a template with your customization class","text":"<p>There are 3 parameters available to change the template rendering from your custom <code>BaseCommitizen</code>.</p> Parameter Type Default Description <code>template</code> <code>str</code> <code>None</code> Provide your own template name (default to <code>CHANGELOG.md.j2</code>) <code>template_loader</code> <code>str</code> <code>None</code> Override the default template loader (so you can provide template from your customization class) <code>template_extras</code> <code>dict</code> <code>None</code> Provide some extra template parameters <p>Let's see an example.</p> <pre><code>from commitizen.cz.base import BaseCommitizen\nfrom jinja2 import PackageLoader\n\n\nclass MyPlugin(BaseCommitizen):\n    template = \"CHANGELOG.md.jinja\"\n    template_loader = PackageLoader(\"my_plugin\", \"templates\")\n    template_extras = {\"key\": \"value\"}\n</code></pre> <p>This snippet will:</p> <ul> <li>use <code>CHANGELOG.md.jinja</code> as template name</li> <li>search for it in the <code>templates</code> directory for <code>my_plugin</code> package</li> <li>add the <code>key=value</code> variable in the template</li> </ul>"},{"location":"customization/#providing-a-template-from-the-current-working-directory","title":"Providing a template from the current working directory","text":"<p>Users can provide their own template from their current working directory (your project root) by:</p> <ul> <li>providing a template with the same name (<code>CHANGELOG.md.j2</code> unless overridden by your custom class)</li> <li>setting your template path as <code>template</code> configuration</li> <li>giving your template path as <code>--template</code> parameter to <code>bump</code> and <code>changelog</code> commands</li> </ul> <p>Note</p> <p>The path is relative to the current working directory, aka your project root most of the time.</p>"},{"location":"customization/#template-variables","title":"Template variables","text":"<p>The default template use a single <code>tree</code> variable which is a list of entries (a release) with the following format:</p> Name Type Description version <code>str</code> The release version date <code>datetime</code> The release date changes <code>list[tuple[str, list[Change]]]</code> The release sorted changes list in the form <code>(type, changes)</code> <p>Each <code>Change</code> has the following fields:</p> Name Type Description scope <code>str | None</code> An optional scope message <code>str</code> The commit message body sha1 <code>str</code> The commit <code>sha1</code> parents <code>list[str]</code> The parent commit(s) <code>sha1</code>(s) author <code>str</code> The commit author name author_email <code>str</code> The commit author email <p>Note</p> <p>The field values depend on the customization class and/or the settings you provide</p> <p>The <code>parents</code> field can be used to identify merge commits and generate a changelog based on those. Another use case is listing commits that belong to the same pull request.</p> <p>When using another template (either provided by a plugin or by yourself), you can also pass extra template variables by:</p> <ul> <li>defining them in your configuration with the <code>extras</code> settings</li> <li>providing them on the command line with the <code>--extra/-e</code> parameter to <code>bump</code> and <code>changelog</code> commands</li> </ul>"},{"location":"exit_codes/","title":"Exit Codes","text":"<p>Commitizen handles expected exceptions through <code>CommitizenException</code> and returns different exit codes for different situations. They could be useful if you want to ignore specific errors in your pipeline.</p> <p>These exit codes can be found in <code>commitizen/exceptions.py::ExitCode</code>.</p> Exception Exit Code Description ExpectedExit 0 Expected exit DryRunExit 0 Exit due to passing <code>--dry-run</code> option NoCommitizenFoundException 1 Using a cz (e.g., <code>cz_jira</code>) that cannot be found in your system NotAGitProjectError 2 Not in a git project NoCommitsFoundError 3 No commit found NoVersionSpecifiedError 4 Version can not be found in configuration file NoPatternMapError 5 bump / changelog pattern or map can not be found in configuration file BumpCommitFailedError 6 Commit error when bumping version BumpTagFailedError 7 Tag error when bumping version NoAnswersError 8 No user response given CommitError 9 git commit error NoCommitBackupError 10 Commit back up file cannot be found NothingToCommitError 11 Nothing in staging to be committed CustomError 12 <code>CzException</code> raised NoCommandFoundError 13 No command found when running Commitizen cli (e.g., <code>cz --debug</code>) InvalidCommitMessageError 14 The commit message does not pass <code>cz check</code> MissingConfigError 15 Configuration missed for <code>cz_customize</code> NoRevisionError 16 No revision found CurrentVersionNotFoundError 17 current version cannot be found in version_files InvalidCommandArgumentError 18 The argument provide to command is invalid (e.g. <code>cz check -commit-msg-file filename --rev-range master..</code>) InvalidConfigurationError 19 An error was found in the Commitizen Configuration, such as duplicates in <code>change_type_order</code> NotAllowed 20 <code>--incremental</code> cannot be combined with a <code>rev_range</code> NoneIncrementExit 21 The commits found are not eligible to be bumped CharacterSetDecodeError 22 The character encoding of the command output could not be determined GitCommandError 23 Unexpected failure while calling a git command InvalidManualVersion 24 Manually provided version is invalid InitFailedError 25 Failed to initialize pre-commit RunHookError 26 An error occurred during a hook execution VersionProviderUnknown 27 <code>version_provider</code> setting is set to an unknown version provider identifier VersionSchemeUnknown 28 <code>version_scheme</code> setting is set to an unknown version scheme identifier ChangelogFormatUnknown 29 <code>changelog_format</code> setting is set to an unknown version scheme identifier or could not be guessed"},{"location":"external_links/","title":"Resources","text":"<p>If you have written over Commitizen, make a PR and add the link here \ud83d\udcaa</p>"},{"location":"external_links/#talks","title":"Talks","text":"Name Speaker Occasion Language Extra commitizen-tools: What can we gain from crafting a git message convention Wei Lee Taipei.py 2020 June Meetup, Remote Python Pizza 2020 English slides Automating release cycles Santiago Fraire PyAmsterdam June 24, 2020, Online English slides Automatizando Releases con Commitizen y Github Actions Santiago Fraire PyConAr 2020, Remote Espa\u00f1ol slides"},{"location":"external_links/#articles","title":"Articles","text":"<ul> <li>Python Table Manners - Commitizen: \u898f\u683c\u5316 commit message (Written in Traditional Mandarin)</li> <li>Automating semantic release with commitizen (English)</li> <li>How to Write Better Git Commit Messages \u2013 A Step-By-Step Guide (English)</li> <li>Continuous delivery made easy (in Python)</li> </ul>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#features-we-wont-add","title":"Features we won't add","text":"<p>For a comprehensive list of features that have been considered but won't be implemented, please refer to our issue tracker.</p> <ul> <li>Enable multiple locations of config file <code>.cz.*</code> #955</li> <li>Create a flag to build the changelog from commits in multiple git repositories #790</li> <li>Global Configuration #597</li> </ul>"},{"location":"faq/#support-for-pep621","title":"Support for PEP621","text":"<p>PEP621 establishes a <code>[project]</code> definition inside <code>pyproject.toml</code></p> <pre><code>[project]\nname = \"spam\"\nversion = \"2.5.1\"\n</code></pre> <p>Commitizen provides a <code>pep621</code> version provider to get and set version from this field. You just need to set the proper <code>version_provider</code> setting:</p> <pre><code>[project]\nname = \"spam\"\nversion = \"2.5.1\"\n\n[tool.commitizen]\nversion_provider = \"pep621\"\n</code></pre>"},{"location":"faq/#why-are-revert-and-chore-valid-types-in-the-check-pattern-of-cz-conventional_commits-but-not-types-we-can-select","title":"Why are <code>revert</code> and <code>chore</code> valid types in the check pattern of cz conventional_commits but not types we can select?","text":"<p><code>revert</code> and <code>chore</code> are added to the \"pattern\" in <code>cz check</code> in order to prevent backward errors, but officially they are not part of conventional commits, we are using the latest types from Angular (they used to but were removed). However, you can create a customized <code>cz</code> with those extra types. (See Customization).</p> <p>See more discussion in issue #142 and #36</p>"},{"location":"faq/#how-to-revert-a-bump","title":"How to revert a bump?","text":"<p>If for any reason, the created tag and changelog were to be undone, this is the snippet:</p> <pre><code>git tag --delete &lt;created_tag&gt;\ngit reset HEAD~\ngit reset --hard HEAD\n</code></pre> <p>This will remove the last tag created, plus the commit containing the update to <code>.cz.toml</code> and the changelog generated for the version.</p> <p>In case the commit was pushed to the server you can remove it by running</p> <pre><code>git push --delete origin &lt;created_tag&gt;\n</code></pre>"},{"location":"faq/#is-this-project-affiliated-with-the-commitizen-js-project","title":"Is this project affiliated with the Commitizen JS project?","text":"<p>It is not affiliated.</p> <p>Both are used for similar purposes, parsing commits, generating changelog and version we presume. This one is written in python to make integration easier for python projects and the other serves the JS packages.</p> <p>They differ a bit in design, not sure if cz-js does any of this, but these are some things you can do with this repo (python's commitizen):</p> <ul> <li>create custom rules, version bumps and changelog generation, by default we use the popular conventional commits (I think cz-js allows this).</li> <li>single package, install one thing and it will work (cz-js is a monorepo, but you have to install different dependencies AFAIK)</li> <li>pre-commit integration</li> <li>works on any language project, as long as you create the <code>.cz.toml</code> or <code>cz.toml</code> file.</li> </ul> <p>Where do they cross paths?</p> <p>If you are using conventional commits in your git history, then you could swap one with the other in theory.</p> <p>Regarding the name, cz-js came first, they used the word Commitizen first. When this project was created originally, the creator read \"be a good commitizen\", and thought it was just a cool word that made sense, and this would be a package that helps you be a good \"commit citizen\".</p>"},{"location":"faq/#how-to-handle-revert-commits","title":"How to handle revert commits?","text":"<pre><code>git revert --no-commit &lt;SHA&gt;\ngit commit -m \"revert: foo bar\"\n</code></pre>"},{"location":"faq/#i-got-exception-winerror-995-the-io-operation-error","title":"I got <code>Exception [WinError 995] The I/O operation ...</code> error","text":"<p>This error was caused by a Python bug on Windows. It's been fixed by this PR, and according to Python's changelog, 3.8.6rc1 and 3.9.0rc2 should be the accurate versions first contain this fix. In conclusion, upgrade your Python version might solve this issue.</p> <p>More discussion can be found in issue #318.</p>"},{"location":"faq/#why-does-commitizen-not-support-calver","title":"Why does Commitizen not support CalVer?","text":"<p><code>commitizen</code> could support CalVer alongside SemVer, but in practice implementing CalVer creates numerous edge cases that are difficult to maintain (#385) and more generally, mixing the two version schemes may not be a good idea. If CalVer or other custom versioning scheme is needed, <code>commitizen</code> could still be used to standardize commits and create changelogs, but a separate package should be used for version increments.</p> <p>Mixing CalVer and SemVer is generally not recommended because each versioning scheme serves a different purpose. Diverging from either specification can be confusing to users and cause errors with third-party tools that don't expect the non-standard format.</p> <p>In the future, <code>commitizen</code> may support some implementation of CalVer, but at the time of writing, there are no plans to implement the feature (#173).</p> <p>If you would like to learn more about both schemes, there are plenty of good resources:</p> <ul> <li>Announcing CalVer</li> <li>API Versioning from Stripe</li> <li>Discussion about pip's use of CalVer</li> <li>Git Version Numbering</li> <li>SemVer vs. CalVer and Why I Use Both (but not at the same time)</li> <li>Semver Will Not Save You</li> <li>Why I Don't Like SemVer</li> </ul>"},{"location":"faq/#how-to-change-the-tag-format","title":"How to change the tag format ?","text":"<p>You can use the <code>legacy_tag_formats</code> to list old tag formats. New bumped tags will be in the new format but old ones will still work for: - changelog generation (full, incremental and version range) - bump new version computation (automatically guessed or increment given)</p> <p>So given if you change from <code>myproject-$version</code> to <code>${version}</code> and then <code>v${version}</code>, your Commitizen configuration will look like this:</p> <pre><code>tag_format = \"v${version}\"\nlegacy_tag_formats = [\n    \"${version}\",\n    \"myproject-$version\",\n]\n</code></pre>"},{"location":"faq/#how-to-avoid-warnings-for-expected-non-version-tags","title":"How to avoid warnings for expected non-version tags","text":"<p>You can explicitly ignore them with <code>ignored_tag_formats</code>.</p> <pre><code>tag_format = \"v${version}\"\nignored_tag_formats = [\n    \"stable\",\n    \"component-*\",\n    \"env/*\",\n    \"v${major}.${minor}\",\n]\n</code></pre>"},{"location":"third-party-commitizen/","title":"Third-Party Commitizen Templates","text":""},{"location":"third-party-commitizen/#third-party-commitizen-templates","title":"Third-Party Commitizen Templates","text":"<p>In addition to the native templates, some alternative commit format templates are available as PyPI packages (installable with <code>pip</code>).</p>"},{"location":"third-party-commitizen/#cz-ai","title":"cz-ai","text":"<p>A Commitizen plugin that leverages OpenAI's GPT-4o to automatically generate clear, concise, and conventional commit messages based on your staged git changes.</p>"},{"location":"third-party-commitizen/#installation","title":"Installation","text":"<pre><code>pip install cz-ai\n</code></pre>"},{"location":"third-party-commitizen/#usage","title":"Usage","text":"<pre><code>cz --name cz_ai commit\n</code></pre>"},{"location":"third-party-commitizen/#conventional-jira","title":"Conventional JIRA","text":"<p>Just like conventional commit format, but the scope has been restricted to a JIRA issue format, i.e. <code>project-issueNumber</code>. This standardises scopes in a meaningful way.</p>"},{"location":"third-party-commitizen/#installation_1","title":"Installation","text":"<pre><code>pip install conventional-JIRA\n</code></pre>"},{"location":"third-party-commitizen/#github-jira-conventional","title":"GitHub JIRA Conventional","text":"<p>This plugin extends the Commitizen tools by:</p> <ul> <li>requiring a JIRA issue ID in the commit message</li> <li>creating links to GitHub commits in the CHANGELOG.md</li> <li>creating links to JIRA issues in the CHANGELOG.md</li> </ul>"},{"location":"third-party-commitizen/#installation_2","title":"Installation","text":"<pre><code>pip install cz-github-jira-conventional\n</code></pre> <p>For installation instructions (configuration and pre-commit) please visit https://github.com/apheris/cz-github-jira-conventional</p>"},{"location":"third-party-commitizen/#cz-emoji","title":"cz-emoji","text":"<p>conventional commit format, but with emojis</p>"},{"location":"third-party-commitizen/#installation_3","title":"Installation","text":"<pre><code>pip install cz-emoji\n</code></pre>"},{"location":"third-party-commitizen/#usage_1","title":"Usage","text":"<pre><code>cz --name cz_emoji commit\n</code></pre>"},{"location":"third-party-commitizen/#cz-conventional-gitmoji","title":"cz-conventional-gitmoji","text":"<p>conventional commits, but with gitmojis.</p> <p>Includes a pre-commit hook that automatically adds the correct gitmoji to the commit message based on the conventional type.</p>"},{"location":"third-party-commitizen/#installation_4","title":"Installation","text":"<pre><code>pip install cz-conventional-gitmoji\n</code></pre>"},{"location":"third-party-commitizen/#usage_2","title":"Usage","text":"<pre><code>cz --name cz_gitmoji commit\n</code></pre>"},{"location":"third-party-commitizen/#commitizen-emoji-unmaintained","title":"Commitizen emoji (Unmaintained)","text":"<p>Just like conventional commit format, but with emojis and optionally time spent and related tasks.</p>"},{"location":"third-party-commitizen/#installation_5","title":"Installation","text":"<pre><code>pip install commitizen-emoji\n</code></pre>"},{"location":"third-party-commitizen/#usage_3","title":"Usage","text":"<pre><code>cz --name cz_commitizen_emoji commit\n</code></pre>"},{"location":"third-party-commitizen/#conventional-legacy-cz_legacy","title":"Conventional Legacy (cz_legacy)","text":"<p>An extension of the conventional commit format to include user-specified legacy change types in the <code>CHANGELOG</code> while preventing the legacy change types from being used in new commit messages</p>"},{"location":"third-party-commitizen/#installation_6","title":"Installation","text":"<pre><code>pip install cz_legacy\n</code></pre>"},{"location":"third-party-commitizen/#usage_4","title":"Usage","text":"<p>See the README for instructions on configuration</p>"},{"location":"third-party-commitizen/#third-party-commitizen-providers","title":"Third-Party Commitizen Providers","text":"<p>Commitizen can read and write version from different sources. In addition to the native providers, some alternative version sources are available as PyPI packages (installable with <code>pip</code>).</p>"},{"location":"third-party-commitizen/#commitizen-deno-provider","title":"commitizen-deno-provider","text":"<p>A provider for Deno projects. The provider updates the version in deno.json and jsr.json files.</p>"},{"location":"third-party-commitizen/#installation_7","title":"Installation","text":"<pre><code>pip install commitizen-deno-provider\n</code></pre>"},{"location":"third-party-commitizen/#usage_5","title":"Usage","text":"<p>Add <code>deno-provider</code> to your configuration file.</p> <p>Example for <code>.cz.yaml</code>:</p> <pre><code>---\ncommitizen:\n  major_version_zero: true\n  name: cz_conventional_commits\n  tag_format: $version\n  update_changelog_on_bump: true\n  version_provider: deno-provider\n  version_scheme: semver\n</code></pre>"},{"location":"commands/bump/","title":"bump","text":""},{"location":"commands/bump/#about","title":"About","text":"<p><code>cz bump</code> is a powerful command that automatically determines and increases your project's version number based on your commit history. It analyzes your commits to determine the appropriate version increment according to semantic versioning principles.</p>"},{"location":"commands/bump/#key-features","title":"Key Features","text":"<ul> <li>Automatic Version Detection: Analyzes commit history to determine the appropriate version bump</li> <li>Manual Version Control: Supports manual version specification when needed</li> <li>Pre-release Support: Handles alpha, beta, and release candidate versions</li> <li>Multiple Version Schemes: Supports both PEP 0440 and semantic versioning formats</li> </ul>"},{"location":"commands/bump/#version-increment-rules","title":"Version Increment Rules","text":"<p>The version follows the <code>MAJOR.MINOR.PATCH</code> format, with increments determined by your commit types:</p> Increment Description Conventional commit map <code>MAJOR</code> Breaking changes introduced <code>BREAKING CHANGE</code>, bang (e.g. <code>feat!</code>) <code>MINOR</code> New features <code>feat</code> <code>PATCH</code> Fixes and improvements <code>fix</code>, <code>perf</code>, <code>refactor</code>"},{"location":"commands/bump/#version-schemes","title":"Version Schemes","text":"<p>By default, Commitizen uses PEP 0440 for version formatting. You can switch to semantic versioning using either:</p> <ol> <li> <p>Command line: <pre><code>cz bump --version-scheme semver\n</code></pre></p> </li> <li> <p>Configuration file: <pre><code>[tool.commitizen]\nversion_scheme = \"semver\"\n</code></pre></p> </li> </ol>"},{"location":"commands/bump/#pep440-version-examples","title":"PEP440 Version Examples","text":"<p>Commitizen supports the PEP 440 version format, which includes several version types. Here are examples of each:</p>"},{"location":"commands/bump/#standard-releases","title":"Standard Releases","text":"<pre><code>0.9.0    # Initial development release\n0.9.1    # Patch release\n0.9.2    # Another patch release\n0.9.10   # Tenth patch release\n0.9.11   # Eleventh patch release\n1.0.0    # First stable release\n1.0.1    # Patch release after stable\n1.1.0    # Minor feature release\n2.0.0    # Major version release\n</code></pre>"},{"location":"commands/bump/#pre-releases","title":"Pre-releases","text":"<pre><code>1.0.0a0  # Alpha release 0\n1.0.0a1  # Alpha release 1\n1.0.0b0  # Beta release 0\n1.0.0rc0 # Release candidate 0\n1.0.0rc1 # Release candidate 1\n</code></pre>"},{"location":"commands/bump/#development-releases","title":"Development Releases","text":"<pre><code>1.0.0.dev0  # Development release 0\n1.0.0.dev1  # Development release 1\n</code></pre>"},{"location":"commands/bump/#combined-pre-release-and-development","title":"Combined Pre-release and Development","text":"<pre><code>1.0.0a1.dev0  # Development release 0 of alpha 1\n1.0.0b2.dev1  # Development release 1 of beta 2\n</code></pre> <p>Note: <code>post</code> releases (e.g., <code>1.0.0.post1</code>) are not currently supported.</p>"},{"location":"commands/bump/#usage","title":"Usage","text":""},{"location":"commands/bump/#-files-only","title":"<code>--files-only</code>","text":"<p>Bumps the version in the files defined in <code>version_files</code> without creating a commit and tag on the git repository,</p> <pre><code>cz bump --files-only\n</code></pre>"},{"location":"commands/bump/#-changelog","title":"<code>--changelog</code>","text":"<p>Generate a changelog along with the new version and tag when bumping.</p> <pre><code>cz bump --changelog\n</code></pre>"},{"location":"commands/bump/#-prerelease","title":"<code>--prerelease</code>","text":"<p>The bump is a pre-release bump, meaning that in addition to a possible version bump the new version receives a pre-release segment compatible with the bump\u2019s version scheme, where the segment consist of a phase and a non-negative number. Supported options for <code>--prerelease</code> are the following phase names <code>alpha</code>, <code>beta</code>, or <code>rc</code> (release candidate). For more details, refer to the Python Packaging User Guide.</p> <p>Note that as per semantic versioning spec</p> <p>Pre-release versions have a lower precedence than the associated normal version. A pre-release version indicates that the version is unstable and might not satisfy the intended compatibility requirements as denoted by its associated normal version.</p> <p>For example, the following versions (using the PEP 440 scheme) are ordered by their precedence and showcase how a release might flow through a development cycle:</p> <ul> <li><code>1.0.0</code> is the current published version</li> <li><code>1.0.1a0</code> after committing a <code>fix:</code> for pre-release</li> <li><code>1.1.0a1</code> after committing an additional <code>feat:</code> for pre-release</li> <li><code>1.1.0b0</code> after bumping a beta release</li> <li><code>1.1.0rc0</code> after bumping the release candidate</li> <li><code>1.1.0</code> next feature release</li> </ul>"},{"location":"commands/bump/#-increment-mode","title":"<code>--increment-mode</code>","text":"<p>By default, <code>--increment-mode</code> is set to <code>linear</code>, which ensures that bumping pre-releases maintains linearity: bumping of a pre-release with lower precedence than the current pre-release phase maintains the current phase of higher precedence. For example, if the current version is <code>1.0.0b1</code> then bumping with <code>--prerelease alpha</code> will continue to bump the \"beta\" phase.</p> <p>Setting <code>--increment-mode</code> to <code>exact</code> instructs <code>cz bump</code> to instead apply the exact changes that have been specified with <code>--increment</code> or determined from the commit log. For example, <code>--prerelease beta</code> will always result in a <code>b</code> tag, and <code>--increment PATCH</code> will always increase the patch component.</p> <p>Below are some examples that illustrate the difference in behavior:</p> Increment Pre-release Start Version <code>--increment-mode=linear</code> <code>--increment-mode=exact</code> <code>MAJOR</code> <code>2.0.0b0</code> <code>2.0.0</code> <code>3.0.0</code> <code>MINOR</code> <code>2.0.0b0</code> <code>2.0.0</code> <code>2.1.0</code> <code>PATCH</code> <code>2.0.0b0</code> <code>2.0.0</code> <code>2.0.1</code> <code>MAJOR</code> <code>alpha</code> <code>2.0.0b0</code> <code>3.0.0a0</code> <code>3.0.0a0</code> <code>MINOR</code> <code>alpha</code> <code>2.0.0b0</code> <code>2.0.0b1</code> <code>2.1.0a0</code> <code>PATCH</code> <code>alpha</code> <code>2.0.0b0</code> <code>2.0.0b1</code> <code>2.0.1a0</code>"},{"location":"commands/bump/#-check-consistency","title":"<code>--check-consistency</code>","text":"<p>Check whether the versions defined in <code>version_files</code> and the version in Commitizen configuration are consistent before bumping version.</p> <pre><code>cz bump --check-consistency\n</code></pre> <p>For example, if we have <code>pyproject.toml</code></p> <pre><code>[tool.commitizen]\nversion = \"1.21.0\"\nversion_files = [\n    \"src/__version__.py\",\n    \"setup.py\",\n]\n</code></pre> <p><code>src/__version__.py</code>,</p> <pre><code>__version__ = \"1.21.0\"\n</code></pre> <p>and <code>setup.py</code>.</p> <pre><code>from setuptools import setup\n\nsetup(..., version=\"1.0.5\", ...)\n</code></pre> <p>If <code>--check-consistency</code> is used, Commitizen will check whether the current version in <code>pyproject.toml</code> exists in all version_files and find out it does not exist in <code>setup.py</code> and fails. However, it will still update <code>pyproject.toml</code> and <code>src/__version__.py</code>.</p> <p>To fix it, you'll first <code>git checkout .</code> to reset to the status before trying to bump and update the version in <code>setup.py</code> to <code>1.21.0</code></p>"},{"location":"commands/bump/#-local-version","title":"<code>--local-version</code>","text":"<p>Bump the local portion of the version.</p> <pre><code>cz bump --local-version\n</code></pre> <p>For example, if we have <code>pyproject.toml</code></p> <pre><code>[tool.commitizen]\nversion = \"5.3.5+0.1.0\"\n</code></pre> <p>If <code>--local-version</code> is used, it will bump only the local version <code>0.1.0</code> and keep the public version <code>5.3.5</code> intact, bumping to the version <code>5.3.5+0.2.0</code>.</p>"},{"location":"commands/bump/#-annotated-tag","title":"<code>--annotated-tag</code>","text":"<p>If <code>--annotated-tag</code> is used, Commitizen will create annotated tags. It is also available via configuration, in <code>pyproject.toml</code> or <code>.cz.toml</code>.</p>"},{"location":"commands/bump/#-annotated-tag-message","title":"<code>--annotated-tag-message</code>","text":"<p>If <code>--annotated-tag-message</code> is used, Commitizen will create annotated tags with the given message.</p>"},{"location":"commands/bump/#-changelog-to-stdout","title":"<code>--changelog-to-stdout</code>","text":"<p>If <code>--changelog-to-stdout</code> is used, the incremental changelog generated by the bump will be sent to the stdout, and any other message generated by the bump will be sent to stderr.</p> <p>If <code>--changelog</code> is not used with this command, it is still smart enough to understand that the user wants to create a changelog. It is recommended to be explicit and use <code>--changelog</code> (or the setting <code>update_changelog_on_bump</code>).</p> <p>This command is useful to \"transport\" the newly created changelog. It can be sent to an auditing system, or to create a GitHub Release.</p> <p>Example:</p> <pre><code>cz bump --changelog --changelog-to-stdout &gt; body.md\n</code></pre>"},{"location":"commands/bump/#-git-output-to-stderr","title":"<code>--git-output-to-stderr</code>","text":"<p>If <code>--git-output-to-stderr</code> is used, git commands output is redirected to stderr.</p> <p>This command is useful when used with <code>--changelog-to-stdout</code> and piping the output to a file, and you don't want the <code>git commit</code> output polluting  the stdout.</p>"},{"location":"commands/bump/#-retry","title":"<code>--retry</code>","text":"<p>If you use tools like pre-commit, add this flag. It will retry the commit if it fails the 1st time.</p> <p>Useful to combine with code formatters, like Prettier.</p>"},{"location":"commands/bump/#-major-version-zero","title":"<code>--major-version-zero</code>","text":"<p>A project in its initial development should have a major version zero, and even breaking changes should not bump that major version from zero. This command ensures that behavior.</p> <p>If <code>--major-version-zero</code> is used for projects that have a version number greater than zero it fails. If used together with a manual version the command also fails.</p> <p>We recommend setting <code>major_version_zero = true</code> in your configuration file while a project is in its initial development. Remove that configuration using a breaking-change commit to bump your project's major version to <code>v1.0.0</code> once your project has reached maturity.</p>"},{"location":"commands/bump/#-version-scheme","title":"<code>--version-scheme</code>","text":"<p>Choose the version format, options: <code>pep440</code>, <code>semver</code>.</p> <p>Default: <code>pep440</code></p> <p>Recommended for python: <code>pep440</code></p> <p>Recommended for other: <code>semver</code></p> <p>You can also set this in the configuration with <code>version_scheme = \"semver\"</code>.</p> <p>pep440 and semver are quite similar, their difference lies in how the prereleases look.</p> schemes pep440 semver non-prerelease <code>0.1.0</code> <code>0.1.0</code> prerelease <code>0.3.1a0</code> <code>0.3.1-a0</code> devrelease <code>0.1.1.dev1</code> <code>0.1.1-dev1</code> dev and pre <code>1.0.0a3.dev1</code> <code>1.0.0-a3-dev1</code> <p>Can I transition from one to the other?</p> <p>Yes, you shouldn't have any issues.</p>"},{"location":"commands/bump/#-template","title":"<code>--template</code>","text":"<p>Provides your own changelog jinja template. See the template customization section</p>"},{"location":"commands/bump/#-extra","title":"<code>--extra</code>","text":"<p>Provides your own changelog extra variables by using the <code>extras</code> settings or the <code>--extra/-e</code> parameter.</p> <pre><code>cz bump --changelog --extra key=value -e short=\"quoted value\"\n</code></pre> <p>See the template customization section.</p>"},{"location":"commands/bump/#-build-metadata","title":"<code>--build-metadata</code>","text":"<p>Provides a way to specify additional metadata in the version string. This parameter is not compatible with <code>--local-version</code> as it uses the same part of the version string.</p> <pre><code>cz bump --build-metadata yourmetadata\n</code></pre> <p>Will create a version like <code>1.1.2+yourmetadata</code>. This can be useful for multiple things - Git hash in version - Labeling the version with additional metadata.</p> <p>Note that Commitizen ignores everything after <code>+</code> when it bumps the version. It is therefore safe to write different build-metadata between versions.</p> <p>You should normally not use this functionality, but if you decide to do, keep in mind that - Version <code>1.2.3+a</code>, and <code>1.2.3+b</code> are the same version! Tools should not use the string after <code>+</code> for version calculation. This is probably not a guarantee (example in helm) even tho it is in the spec. - It might be problematic having the metadata in place when doing upgrades depending on what tool you use.</p>"},{"location":"commands/bump/#-get-next","title":"<code>--get-next</code>","text":"<p>Provides a way to determine the next version and write it to stdout. This parameter is not compatible with <code>--changelog</code> and <code>manual version</code>.</p> <pre><code>cz bump --get-next\n</code></pre> <p>Will output the next version, e.g., <code>1.2.3</code>. This can be useful for determining the next version based on CI for non production environments/builds.</p> <p>This behavior differs from the <code>--dry-run</code> flag. The <code>--dry-run</code> flag provides a more detailed output and can also show the changes as they would appear in the changelog file.</p> <p>The following output is the result of <code>cz bump --dry-run</code>:</p> <pre><code>bump: version 3.28.0 \u2192 3.29.0\ntag to create: v3.29.0\nincrement detected: MINOR\n</code></pre> <p>The following output is the result of <code>cz bump --get-next</code>:</p> <pre><code>3.29.0\n</code></pre> <p>The <code>--get-next</code> flag will raise a <code>NoneIncrementExit</code> if the found commits are not eligible for a version bump.</p> <p>For information on how to suppress this exit, see avoid raising errors.</p>"},{"location":"commands/bump/#-allow-no-commit","title":"<code>--allow-no-commit</code>","text":"<p>Allow the project version to be bumped even when there's no eligible version. This is most useful when used with <code>--increment {MAJOR,MINOR,PATCH}</code> or <code>[MANUL_VERSION]</code></p> <pre><code># bump a minor version even when there's only bug fixes, documentation changes or even no commits\ncz bump --incremental MINOR --allow-no-commit\n\n# bump version to 2.0.0 even when there's no breaking changes changes or even no commits\ncz bump --allow-no-commit 2.0.0\n</code></pre>"},{"location":"commands/bump/#avoid-raising-errors","title":"Avoid raising errors","text":"<p>Some situations from Commitizen raise an exit code different from 0. If the error code is different from 0, any CI or script running Commitizen might be interrupted.</p> <p>If you have a special use case, where you don't want to raise one of this error codes, you can tell Commitizen to not raise them.</p>"},{"location":"commands/bump/#recommended-use-case","title":"Recommended use case","text":"<p>At the moment, we've identified that the most common error code to skip is</p> Error name Exit code NoneIncrementExit 21 <p>There are some situations where you don't want to get an error code when some commits do not match your rules, you just want those commits to be skipped.</p> <pre><code>cz -nr 21 bump\n</code></pre>"},{"location":"commands/bump/#easy-way","title":"Easy way","text":"<p>Check which error code was raised by Commitizen by running in the terminal</p> <pre><code>echo $?\n</code></pre> <p>The output should be an integer like this</p> <pre><code>3\n</code></pre> <p>And then you can tell Commitizen to ignore it:</p> <pre><code>cz --no-raise 3\n</code></pre> <p>You can tell Commitizen to skip more than one if needed:</p> <pre><code>cz --no-raise 3,4,5\n</code></pre>"},{"location":"commands/bump/#longer-way","title":"Longer way","text":"<p>Check the list of exit_codes and understand which one you have to skip and why.</p> <p>Remember to document somewhere this, because you'll forget.</p> <p>For example if the system raises a <code>NoneIncrementExit</code> error, you look it up on the list, and then you can use the exit code:</p> <pre><code>cz -nr 21 bump\n</code></pre>"},{"location":"commands/bump/#configuration","title":"Configuration","text":""},{"location":"commands/bump/#tag_format","title":"<code>tag_format</code>","text":"<p><code>tag_format</code> and <code>version_scheme</code> are combined to make Git tag names from versions.</p> <p>These are used in:</p> <ul> <li><code>cz bump</code>: Find previous release tag (exact match) and generate new tag.</li> <li>Find previous release tags in <code>cz changelog</code>.</li> <li>If <code>--incremental</code>: Using the latest version found in the changelog, scan existing Git tags with 89\\% similarity match.</li> <li><code>--rev-range</code> is converted to Git tag names with <code>tag_format</code> before searching Git history.</li> <li>If the <code>scm</code> <code>version_provider</code> is used, it uses different regexes to find the previous version tags:</li> <li>If <code>tag_format</code> is set to <code>$version</code> (default): <code>VersionProtocol.parser</code> (allows <code>v</code> prefix)</li> <li>If <code>tag_format</code> is set: Custom regex similar to SemVer (not as lenient as PEP440 e.g. on dev-releases)</li> </ul> <p>Commitizen supports 2 types of formats, a simple and a more complex.</p> <pre><code>cz bump --tag-format=\"v$version\"\n</code></pre> <pre><code>cz bump --tag-format=\"v$minor.$major.$patch$prerelease.$devrelease\"\n</code></pre> <p>In your <code>pyproject.toml</code> or <code>.cz.toml</code></p> <pre><code>[tool.commitizen]\ntag_format = \"v$major.$minor.$patch$prerelease\"\n</code></pre> <p>The variables must be preceded by a <code>$</code> sign and optionally can be wrapped in <code>{}</code> . Default is <code>$version</code>.</p> <p>Supported variables:</p> Variable Description <code>$version</code>, <code>${version}</code> full generated version <code>$major</code>, <code>${major}</code> MAJOR increment <code>$minor</code>, <code>${minor}</code> MINOR increment <code>$patch</code>, <code>${patch}</code> PATCH increment <code>$prerelease</code>, <code>${prerelease}</code> Prerelease (alpha, beta, release candidate) <code>$devrelease</code>, ${devrelease}` Development release"},{"location":"commands/bump/#version_files","title":"<code>version_files</code> *","text":"<p>It is used to identify the files which should be updated with the new version. It is also possible to provide a pattern for each file, separated by colons (<code>:</code>).</p> <p>Commitizen will update its configuration file automatically (<code>pyproject.toml</code>, <code>.cz</code>) when bumping, regarding if the file is present or not in <code>version_files</code>.</p> <p>* Renamed from <code>files</code> to <code>version_files</code>.</p> <p>Some examples</p> <p><code>pyproject.toml</code>, <code>.cz.toml</code> or <code>cz.toml</code></p> <pre><code>[tool.commitizen]\nversion_files = [\n    \"src/__version__.py\",\n    \"setup.py:version\"\n]\n</code></pre> <p>In the example above, we can see the reference <code>\"setup.py:version\"</code>. This means that it will find a file <code>setup.py</code> and will only make a change in a line containing the <code>version</code> substring.</p> <p>Note</p> <p>Files can be specified using relative (to the execution) paths, absolute paths or glob patterns.</p>"},{"location":"commands/bump/#bump_message","title":"<code>bump_message</code>","text":"<p>Template used to specify the commit message generated when bumping.</p> <p>Defaults to: <code>bump: version $current_version \u2192 $new_version</code></p> Variable Description <code>$current_version</code> the version existing before bumping <code>$new_version</code> version generated after bumping <p>Some examples</p> <p><code>pyproject.toml</code>, <code>.cz.toml</code> or <code>cz.toml</code></p> <pre><code>[tool.commitizen]\nbump_message = \"release $current_version \u2192 $new_version [skip-ci]\"\n</code></pre>"},{"location":"commands/bump/#update_changelog_on_bump","title":"<code>update_changelog_on_bump</code>","text":"<p>When set to <code>true</code> the changelog is always updated incrementally when running <code>cz bump</code>, so the user does not have to provide the <code>--changelog</code> flag every time.</p> <p>Defaults to: <code>false</code></p> <pre><code>[tool.commitizen]\nupdate_changelog_on_bump = true\n</code></pre>"},{"location":"commands/bump/#annotated_tag","title":"<code>annotated_tag</code>","text":"<p>When set to <code>true</code>, Commitizen will create annotated tags.</p> <pre><code>[tool.commitizen]\nannotated_tag = true\n</code></pre>"},{"location":"commands/bump/#gpg_sign","title":"<code>gpg_sign</code>","text":"<p>When set to <code>true</code>, Commitizen will create gpg signed tags.</p> <pre><code>[tool.commitizen]\ngpg_sign = true\n</code></pre>"},{"location":"commands/bump/#major_version_zero","title":"<code>major_version_zero</code>","text":"<p>When set to <code>true</code>, Commitizen will keep the major version at zero. Useful during the initial development stage of your project.</p> <p>Defaults to: <code>false</code></p> <pre><code>[tool.commitizen]\nmajor_version_zero = true\n</code></pre>"},{"location":"commands/bump/#pre_bump_hooks","title":"<code>pre_bump_hooks</code>","text":"<p>A list of optional commands that will run right after updating <code>version_files</code> and before actual committing and tagging the release.</p> <p>Useful when you need to generate documentation based on the new version. During execution of the script, some environment variables are available:</p> Variable Description <code>CZ_PRE_IS_INITIAL</code> <code>True</code> when this is the initial release, <code>False</code> otherwise <code>CZ_PRE_CURRENT_VERSION</code> Current version, before the bump <code>CZ_PRE_CURRENT_TAG_VERSION</code> Current version tag, before the bump <code>CZ_PRE_NEW_VERSION</code> New version, after the bump <code>CZ_PRE_NEW_TAG_VERSION</code> New version tag, after the bump <code>CZ_PRE_MESSAGE</code> Commit message of the bump <code>CZ_PRE_INCREMENT</code> Whether this is a <code>MAJOR</code>, <code>MINOR</code> or <code>PATH</code> release <code>CZ_PRE_CHANGELOG_FILE_NAME</code> Path to the changelog file, if available <pre><code>[tool.commitizen]\npre_bump_hooks = [\n  \"scripts/generate_documentation.sh\"\n]\n</code></pre>"},{"location":"commands/bump/#post_bump_hooks","title":"<code>post_bump_hooks</code>","text":"<p>A list of optional commands that will run right after committing and tagging the release.</p> <p>Useful when you need to send notifications about a release, or further automate deploying the release. During execution of the script, some environment variables are available:</p> Variable Description <code>CZ_POST_WAS_INITIAL</code> <code>True</code> when this was the initial release, <code>False</code> otherwise <code>CZ_POST_PREVIOUS_VERSION</code> Previous version, before the bump <code>CZ_POST_PREVIOUS_TAG_VERSION</code> Previous version tag, before the bump <code>CZ_POST_CURRENT_VERSION</code> Current version, after the bump <code>CZ_POST_CURRENT_TAG_VERSION</code> Current version tag, after the bump <code>CZ_POST_MESSAGE</code> Commit message of the bump <code>CZ_POST_INCREMENT</code> Whether this was a <code>MAJOR</code>, <code>MINOR</code> or <code>PATH</code> release <code>CZ_POST_CHANGELOG_FILE_NAME</code> Path to the changelog file, if available <pre><code>[tool.commitizen]\npost_bump_hooks = [\n  \"scripts/slack_notification.sh\"\n]\n</code></pre>"},{"location":"commands/bump/#prerelease_offset","title":"<code>prerelease_offset</code>","text":"<p>Offset with which to start counting prereleases.</p> <p>Defaults to: <code>0</code></p> <pre><code>[tool.commitizen]\nprerelease_offset = 1\n</code></pre>"},{"location":"commands/bump/#version_scheme","title":"<code>version_scheme</code>","text":"<p>Choose version scheme</p> schemes pep440 semver semver2 non-prerelease <code>0.1.0</code> <code>0.1.0</code> <code>0.1.0</code> prerelease <code>0.3.1a0</code> <code>0.3.1-a0</code> <code>0.3.1-alpha.0</code> devrelease <code>0.1.1.dev1</code> <code>0.1.1-dev1</code> <code>0.1.1-dev.1</code> dev and pre <code>1.0.0a3.dev1</code> <code>1.0.0-a3-dev1</code> <code>1.0.0-alpha.3.dev.1</code> <p>Options: <code>pep440</code>, <code>semver</code>, <code>semver2</code></p> <p>Defaults to: <code>pep440</code></p> <pre><code>[tool.commitizen]\nversion_scheme = \"semver\"\n</code></pre>"},{"location":"commands/bump/#custom-bump","title":"Custom bump","text":"<p>Read the customizing section.</p>"},{"location":"commands/changelog/","title":"changelog","text":""},{"location":"commands/changelog/#about","title":"About","text":"<p>This command will generate a changelog following the committing rules established.</p> <p>To create the changelog automatically on bump, add the setting update_changelog_on_bump</p> <pre><code>[tool.commitizen]\nupdate_changelog_on_bump = true\n</code></pre>"},{"location":"commands/changelog/#usage","title":"Usage","text":""},{"location":"commands/changelog/#examples","title":"Examples","text":""},{"location":"commands/changelog/#generate-full-changelog","title":"Generate full changelog","text":"<pre><code>cz changelog\n</code></pre> <pre><code>cz ch\n</code></pre>"},{"location":"commands/changelog/#get-the-changelog-for-the-given-version","title":"Get the changelog for the given version","text":"<pre><code>cz changelog 0.3.0 --dry-run\n</code></pre>"},{"location":"commands/changelog/#get-the-changelog-for-the-given-version-range","title":"Get the changelog for the given version range","text":"<pre><code>cz changelog 0.3.0..0.4.0 --dry-run\n</code></pre>"},{"location":"commands/changelog/#constrains","title":"Constrains","text":"<p>changelog generation is constrained only to markdown files.</p>"},{"location":"commands/changelog/#description","title":"Description","text":"<p>These are the variables used by the changelog generator.</p> <pre><code># &lt;version&gt; (&lt;date&gt;)\n\n## &lt;change_type&gt;\n\n- **&lt;scope&gt;**: &lt;message&gt;\n</code></pre> <p>It will create a full block like above per version found in the tags. And it will create a list of the commits found. The <code>change_type</code> and the <code>scope</code> are optional, they don't need to be provided, but if your regex does, they will be rendered.</p> <p>The format followed by the changelog is the one from keep a changelog and the following variables are expected:</p> Variable Description Source <code>version</code> Version number which should follow semver <code>tags</code> <code>date</code> Date in which the tag was created <code>tags</code> <code>change_type</code> The group where the commit belongs to, this is optional. Example: fix <code>commit regex</code> <code>message</code>* Information extracted from the commit message <code>commit regex</code> <code>scope</code> Contextual information. Should be parsed using the regex from the message, it will be bold <code>commit regex</code> <code>breaking</code> Whether is a breaking change or not <code>commit regex</code> <ul> <li>required: is the only one required to be parsed by the regex</li> </ul>"},{"location":"commands/changelog/#configuration","title":"Configuration","text":""},{"location":"commands/changelog/#unreleased_version","title":"<code>unreleased_version</code>","text":"<p>There is usually a chicken and egg situation when automatically bumping the version and creating the changelog. If you bump the version first, you have no changelog, you have to create it later, and it won't be included in the release of the created version.</p> <p>If you create the changelog before bumping the version, then you usually don't have the latest tag, and the Unreleased title appears.</p> <p>By introducing <code>unreleased_version</code> you can prevent this situation.</p> <p>Before bumping you can run:</p> <pre><code>cz changelog --unreleased-version=\"v1.0.0\"\n</code></pre> <p>Remember to use the tag instead of the raw version number</p> <p>For example if the format of your tag includes a <code>v</code> (<code>v1.0.0</code>), then you should use that, if your tag is the same as the raw version, then ignore this.</p> <p>Alternatively you can directly bump the version and create the changelog by doing</p> <pre><code>cz bump --changelog\n</code></pre>"},{"location":"commands/changelog/#file-name","title":"<code>file-name</code>","text":"<p>This value can be updated in the <code>toml</code> file with the key <code>changelog_file</code> under <code>tools.commitizen</code></p> <p>Specify the name of the output file, remember that changelog only works with Markdown.</p> <pre><code>cz changelog --file-name=\"CHANGES.md\"\n</code></pre>"},{"location":"commands/changelog/#incremental","title":"<code>incremental</code>","text":"<p>This flag can be set in the <code>toml</code> file with the key <code>changelog_incremental</code> under <code>tools.commitizen</code></p> <p>Benefits:</p> <ul> <li>Build from the latest version found in changelog, this is useful if you have a different changelog and want to use commitizen</li> <li>Update unreleased area</li> <li>Allows users to manually touch the changelog without being rewritten.</li> </ul> <pre><code>cz changelog --incremental\n</code></pre> <pre><code>[tools.commitizen]\n# ...\nchangelog_incremental = true\n</code></pre>"},{"location":"commands/changelog/#start-rev","title":"<code>start-rev</code>","text":"<p>This value can be set in the <code>toml</code> file with the key <code>changelog_start_rev</code> under <code>tools.commitizen</code></p> <p>Start from a given git rev to generate the changelog. Commits before that rev will not be considered. This is especially useful for long-running projects adopting conventional commits, where old commit messages might fail to be parsed for changelog generation.</p> <pre><code>cz changelog --start-rev=\"v0.2.0\"\n</code></pre> <pre><code>[tools.commitizen]\n# ...\nchangelog_start_rev = \"v0.2.0\"\n</code></pre>"},{"location":"commands/changelog/#merge-prerelease","title":"merge-prerelease","text":"<p>This flag can be set in the <code>toml</code> file with the key <code>changelog_merge_prerelease</code> under <code>tools.commitizen</code></p> <p>Collects changes from prereleases into the next non-prerelease. This means that if you have a prerelease version, and then a normal release, the changelog will show the prerelease changes as part of the changes of the normal release. If not set, it will include prereleases in the changelog.</p> <pre><code>cz changelog --merge-prerelease\n</code></pre> <pre><code>[tools.commitizen]\n# ...\nchangelog_merge_prerelease = true\n</code></pre>"},{"location":"commands/changelog/#template","title":"<code>template</code>","text":"<p>Provides your own changelog jinja template by using the <code>template</code> settings or the <code>--template</code> parameter. See the template customization section</p>"},{"location":"commands/changelog/#extras","title":"<code>extras</code>","text":"<p>Provides your own changelog extra variables by using the <code>extras</code> settings or the <code>--extra/-e</code> parameter.</p> <pre><code>cz changelog --extra key=value -e short=\"quoted value\"\n</code></pre> <p>See the template customization section</p>"},{"location":"commands/changelog/#hooks","title":"Hooks","text":"<p>Supported hook methods:</p> <ul> <li>Per parsed message: Useful to add links</li> <li>End of changelog generation: Useful to send Slack or chat messages, or notify another department</li> </ul> <p>Read more about hooks in the customization page</p>"},{"location":"commands/check/","title":"Check","text":""},{"location":"commands/check/#about","title":"About","text":"<p>This feature checks whether the commit message follows the given committing rules. Comments in git messages will be ignored.</p> <p>If you want to set up an automatic check before every git commit, please refer to Automatically check message before commit.</p>"},{"location":"commands/check/#usage","title":"Usage","text":"<p>There are three mutually exclusive ways to use <code>cz check</code>:</p> <ul> <li>with <code>--rev-range</code> to check a range of pre-existing commits</li> <li>with <code>--message</code> or by piping the message to it to check a given string</li> <li>or with <code>--commit-msg-file</code> to read the commit message from a file</li> </ul>"},{"location":"commands/check/#git-rev-range","title":"Git Rev Range","text":"<p>If you'd like to check a commit's message after it has already been created, then you can specify the range of commits to check with <code>--rev-range REV_RANGE</code>.</p> <pre><code>$ cz check --rev-range REV_RANGE\n</code></pre> <p>For example, if you'd like to check all commits on a branch, you can use <code>--rev-range master..HEAD</code>. Or, if you'd like to check all commits starting from when you first implemented commit message linting, you can use <code>--rev-range &lt;first_commit_sha&gt;..HEAD</code>.</p> <p>For more information on how git commit ranges work, you can check the git documentation.</p>"},{"location":"commands/check/#commit-message","title":"Commit Message","text":"<p>There are two ways you can provide your plain message and check it.</p>"},{"location":"commands/check/#method-1-use-m-or-message","title":"Method 1: use -m or --message","text":"<pre><code>$ cz check --message MESSAGE\n</code></pre> <p>In this option, MESSAGE is the commit message to be checked.</p>"},{"location":"commands/check/#method-2-use-pipe-to-pipe-it-to-cz-check","title":"Method 2: use pipe to pipe it to <code>cz check</code>","text":"<pre><code>$ echo MESSAGE | cz check\n</code></pre> <p>In this option, MESSAGE is piped to cz check and will be checked.</p>"},{"location":"commands/check/#commit-message-file","title":"Commit Message File","text":"<pre><code>$ cz check --commit-msg-file COMMIT_MSG_FILE\n</code></pre> <p>In this option, COMMIT_MSG_FILE is the path of the temporary file that contains the commit message. This argument can be useful when cooperating with git hooks. Please check Automatically check message before commit for more information about how to use this argument with git hooks.</p>"},{"location":"commands/check/#allow-abort","title":"Allow Abort","text":"<pre><code>cz check --message MESSAGE --allow-abort\n</code></pre> <p>Empty commit messages typically instruct Git to abort a commit, so you can pass <code>--allow-abort</code> to permit them. Since <code>git commit</code> accepts an <code>--allow-empty-message</code> flag (primarily for wrapper scripts), you may wish to disallow such commits in CI. <code>--allow-abort</code> may be used in conjunction with any of the other options.</p>"},{"location":"commands/check/#allowed-prefixes","title":"Allowed Prefixes","text":"<p>If the commit message starts with some specific prefixes, <code>cz check</code> returns <code>True</code> without checking the regex. By default, the following prefixes are allowed: <code>Merge</code>, <code>Revert</code>, <code>Pull request</code>, <code>fixup!</code> and <code>squash!</code>.</p> <pre><code>cz check --message MESSAGE --allowed-prefixes 'Merge' 'Revert' 'Custom Prefix'\n</code></pre>"},{"location":"commands/check/#commit-message-length-limit","title":"Commit message length limit","text":"<p>The argument <code>-l</code> (or <code>--message-length-limit</code>) followed by a positive number can limit the length of commit messages. For example, <code>cz check --message MESSAGE -l 3</code> would fail the check, since <code>MESSAGE</code> is more than 3 characters long. By default, the limit is set to 0, which means no limit on the length.</p> <p>Note that the limit applies only to the first line of the message. Specifically, for <code>ConventionalCommitsCz</code> the length only counts from the type of change to the subject, while the body and the footer are not counted.</p>"},{"location":"commands/commit/","title":"commit","text":""},{"location":"commands/commit/#about","title":"About","text":"<p>In your terminal run <code>cz commit</code> or the shortcut <code>cz c</code> to generate a guided git commit.</p> <p>You can run <code>cz commit --write-message-to-file COMMIT_MSG_FILE</code> to additionally save the generated message to a file. This can be combined with the <code>--dry-run</code> flag to only write the message to a file and not modify files and create a commit. A possible use case for this is to automatically prepare a commit message.</p> <p>Note</p> <p>To maintain platform compatibility, the <code>commit</code> command disable ANSI escaping in its output. In particular pre-commit hooks coloring will be deactivated as discussed in commitizen-tools/commitizen#417.</p>"},{"location":"commands/commit/#usage","title":"Usage","text":""},{"location":"commands/commit/#git-options","title":"git options","text":"<p><code>git</code> command options that are not implemented by Commitizen can be use via the <code>--</code> syntax for the <code>commit</code> command. The syntax separates Commitizen arguments from <code>git commit</code> arguments by a double dash. This is the resulting syntax: <pre><code>cz commit &lt;commitizen-args&gt; -- &lt;git-cli-args&gt;\n\n# e.g., cz commit --dry-run -- -a -S\n</code></pre> For example, using the <code>-S</code> option on <code>git commit</code> to sign a commit is now Commitizen compatible: <code>cz c -- -S</code></p> <p>Note</p> <p>Deprecation warning: A commit can be signed off using <code>cz commit --signoff</code> or the shortcut <code>cz commit -s</code>. This syntax is now deprecated in favor of the new <code>cz commit -- -s</code> syntax.</p>"},{"location":"commands/commit/#retry","title":"Retry","text":"<p>You can use <code>cz commit --retry</code> to reuse the last commit message when the previous commit attempt failed. To automatically retry when running <code>cz commit</code>, you can set the <code>retry_after_failure</code> configuration option to <code>true</code>. Running <code>cz commit --no-retry</code> makes Commitizen ignore <code>retry_after_failure</code>, forcing a new commit message to be prompted.</p>"},{"location":"commands/commit/#commit-message-length-limit","title":"Commit message length limit","text":"<p>The argument <code>-l</code> (or <code>--message-length-limit</code>) followed by a positive number can limit the length of commit messages. An exception would be raised when the message length exceeds the limit. For example, <code>cz commit -l 72</code> will limit the length of commit messages to 72 characters. By default, the limit is set to 0, which means no limit on the length.</p> <p>Note that the limit applies only to the first line of the message. Specifically, for <code>ConventionalCommitsCz</code> the length only counts from the type of change to the subject, while the body and the footer are not counted.</p>"},{"location":"commands/example/","title":"example","text":"<p>Show commit example</p>"},{"location":"commands/example/#usage","title":"Usage","text":""},{"location":"commands/info/","title":"info","text":"<p>Show information about the cz</p>"},{"location":"commands/info/#usage","title":"Usage","text":""},{"location":"commands/init/","title":"init","text":"<p>The <code>cz init</code> command helps you set up Commitizen in your project by creating a configuration file with your preferred settings.</p>"},{"location":"commands/init/#usage","title":"Usage","text":""},{"location":"commands/init/#command","title":"Command","text":"<pre><code>cz init\n</code></pre>"},{"location":"commands/init/#interactive-configuration","title":"Interactive Configuration","text":"<p>When you run <code>cz init</code>, Commitizen will guide you through an interactive setup process:</p> <p></p>"},{"location":"commands/init/#configuration-file","title":"Configuration File","text":"<p>The initialization process will create a configuration file in your project root.</p> <p>Choose the configuration file format based on your project type:</p> <ul> <li>Use <code>pyproject.toml</code> for Python projects</li> <li>Use <code>.cz.toml</code>, <code>.cz.yaml</code>, <code>.cz.json</code>, etc. for other projects.</li> </ul>"},{"location":"commands/init/#configuration-options","title":"Configuration Options","text":"<p>During the initialization process, you'll be prompted to configure the following settings:</p> <ol> <li>Convention Rules: Select the commit message convention to follow (e.g., conventional commits)</li> <li>Version Provider: Choose how to manage versioning in your project. Commitizen supports multiple version management systems:<ul> <li><code>commitizen</code>: Uses Commitizen's built-in version management system</li> <li><code>npm</code>: Manages version in <code>package.json</code> for Node.js projects</li> <li><code>cargo</code>: Manages version in <code>Cargo.toml</code> for Rust projects</li> <li><code>composer</code>: Manages version in <code>composer.json</code> for PHP projects</li> <li><code>pep621</code>: Uses <code>pyproject.toml</code> with PEP 621 standard</li> <li><code>poetry</code>: Uses <code>pyproject.toml</code> with Poetry configuration</li> <li><code>uv</code>: Uses <code>pyproject.toml</code> and <code>uv.lock</code> for Python projects</li> <li><code>scm</code>: Reads version directly from git tags without modifying files</li> </ul> </li> <li>Project Version: The current version of your project will be detected automatically</li> <li>Tag Format: The format used for version tags in your repository</li> <li>Version Type: Choose between:<ul> <li><code>semver</code> or <code>semver2</code>: Semantic Versioning (MAJOR.MINOR.PATCH)</li> <li><code>pep440</code>: Python Package Versioning</li> </ul> </li> <li>Changelog Generation: Configure whether to automatically generate changelog during version bumps</li> <li>Alpha Versioning: Option to keep major version at 0 for alpha/beta software</li> <li>Pre-commit Hooks: Set up Git pre-commit hooks for automated commit message validation</li> </ol>"},{"location":"commands/init/#example","title":"Example","text":"<pre><code># Start the initialization process\ncz init\n\n# Follow the interactive prompts to configure your project\n</code></pre>"},{"location":"commands/init/#next-steps","title":"Next Steps","text":"<p>After initialization, you can:</p> <ol> <li>Start using <code>cz commit</code> to create conventional commits</li> <li>Use <code>cz bump</code> to manage versioning</li> <li>Configure additional settings in your project's configuration file</li> </ol>"},{"location":"commands/ls/","title":"ls","text":""},{"location":"commands/ls/#usage","title":"Usage","text":""},{"location":"commands/schema/","title":"schema","text":"<p>Show commit schema</p>"},{"location":"commands/schema/#usage","title":"Usage","text":""},{"location":"commands/version/","title":"version","text":"<p>Get the version of the installed Commitizen or the current project (default: installed commitizen)</p>"},{"location":"commands/version/#usage","title":"Usage","text":""},{"location":"tutorials/auto_check/","title":"Automatically check message before commit","text":""},{"location":"tutorials/auto_check/#about","title":"About","text":"<p>To automatically check a commit message prior to committing, you can use a git hook.</p>"},{"location":"tutorials/auto_check/#how-to","title":"How to","text":"<p>There are two common methods for installing the hooks:</p>"},{"location":"tutorials/auto_check/#method-1-add-a-git-hook-through-pre-commit","title":"Method 1: Add a git hook through pre-commit","text":"<ul> <li>Step 1: Install pre-commit</li> </ul> <pre><code>python -m pip install pre-commit\n</code></pre> <ul> <li>Step 2: Create <code>.pre-commit-config.yaml</code> in your root directory with the following content</li> </ul> <pre><code>---\nrepos:\n  - repo: https://github.com/commitizen-tools/commitizen\n    rev: v1.17.0\n    hooks:\n      - id: commitizen\n        stages: [commit-msg]\n</code></pre> <ul> <li>Step 3: Install the configuration into the git hook through <code>pre-commit</code></li> </ul> <pre><code>pre-commit install --hook-type commit-msg\n</code></pre>"},{"location":"tutorials/auto_check/#method-2-manually-add-a-git-hook","title":"Method 2: Manually add a git hook","text":"<p>The command might be included inside a Git hook (inside <code>.git/hooks/</code> at the root of the project).</p> <p>The selected hook might be the file called commit-msg.</p> <p>This example shows how to use the check command inside commit-msg.</p> <p>At the root of the project:</p> <pre><code>cd .git/hooks\ntouch commit-msg\nchmod +x commit-msg\n</code></pre> <p>Open the file and edit it:</p> <pre><code>#!/bin/bash\nMSG_FILE=$1\ncz check --allow-abort --commit-msg-file $MSG_FILE\n</code></pre> <p>Where <code>$1</code> is the name of the temporary file that contains the current commit message. To be more explicit, the previous variable is stored in another variable called <code>$MSG_FILE</code>, for didactic purposes.</p> <p>The <code>--commit-msg-file</code> flag is required, not optional.</p> <p>Each time you create a commit, this hook will automatically analyze it. If the commit message is invalid, it will be rejected.</p> <p>The commit should follow the given committing rules; otherwise, it won't be accepted.</p>"},{"location":"tutorials/auto_prepare_commit_message/","title":"Automatically prepare message before commit","text":""},{"location":"tutorials/auto_prepare_commit_message/#about","title":"About","text":"<p>It can be desirable to use Commitizen for all types of commits (i.e. regular, merge, squash) so that the complete git history adheres to the commit message convention without ever having to call <code>cz commit</code>.</p> <p>To automatically prepare a commit message prior to committing, you can use a prepare-commit-msg Git hook:</p> <p>This hook is invoked by git-commit right after preparing the default log message, and before the editor is started.</p> <p>To automatically perform arbitrary cleanup steps after a successful commit you can use a post-commit Git hook:</p> <p>This hook is invoked by git-commit. It takes no parameters, and is invoked after a commit is made.</p> <p>A combination of these two hooks allows for enforcing the usage of Commitizen so that whenever a commit is about to be created, Commitizen is used for creating the commit message. Running <code>git commit</code> or <code>git commit -m \"...\"</code> for example, would trigger Commitizen and use the generated commit message for the commit.</p>"},{"location":"tutorials/auto_prepare_commit_message/#installation","title":"Installation","text":"<p>Copy the hooks from here into the <code>.git/hooks</code> folder and make them   executable by running the following commands from the root of your Git repository:</p> <pre><code>wget -O .git/hooks/prepare-commit-msg https://raw.githubusercontent.com/commitizen-tools/commitizen/master/hooks/prepare-commit-msg.py\nchmod +x .git/hooks/prepare-commit-msg\nwget -O .git/hooks/post-commit https://raw.githubusercontent.com/commitizen-tools/commitizen/master/hooks/post-commit.py\nchmod +x .git/hooks/post-commit\n</code></pre>"},{"location":"tutorials/auto_prepare_commit_message/#features","title":"Features","text":"<ul> <li>Commits can be created using both <code>cz commit</code> and the regular <code>git commit</code></li> <li>The hooks automatically create a backup of the commit message that can be reused if   the commit failed</li> <li>The commit message backup can also be used via <code>cz commit --retry</code></li> </ul>"},{"location":"tutorials/dev_releases/","title":"Dev Releases","text":""},{"location":"tutorials/dev_releases/#about","title":"About","text":"<p>To make use of a <code>.dev</code> suffix, as per PEP440.</p> <p>If multiple active branches attempt to create a tag relative to the main branch, there is a possibility that they will attempt to create the same tag, resulting in a collision.</p> <p>Developmental releases aim to avoid this by including a <code>.dev</code> segment which includes a non-negative integer unique to that workflow:</p> <pre><code>X.Y.devN\n</code></pre> <p>Note</p> <p>As noted in PEP440, while developmental releases help avoid the situation described above, they can be \"difficult to parse for human readers\" depending on the value passed as the developmental release.</p>"},{"location":"tutorials/dev_releases/#how-to","title":"How to","text":""},{"location":"tutorials/dev_releases/#example-1-circleci","title":"Example 1: CircleCI","text":"<p>For example, CircleCI provides <code>CIRCLE_BUILD_NUM</code>, a unique number for each job which will increment with each run:</p> <pre><code>--devrelease ${CIRCLE_BUILD_NUM}\n</code></pre> <p>This will result in a unique developmental release of, for example:</p> <pre><code>1.3.2.dev2478\n</code></pre>"},{"location":"tutorials/dev_releases/#example-2-github","title":"Example 2: GitHub","text":"<p>GitHub also provides <code>GITHUB_RUN_ID</code>, a \"unique number for each workflow run\" which will also provide a unique number for each workflow:</p> <pre><code>--devrelease ${GITHUB_RUN_ID}\n</code></pre> <p>This will result in a unique developmental release of, for example:</p> <pre><code>1.3.2.dev6048584598\n</code></pre>"},{"location":"tutorials/dev_releases/#example-3-unix-time","title":"Example 3: Unix time","text":"<p>Equally, as the developmental release needs only a non-negative integer, it is possible to use the Unix time (i.e. the number of seconds since 1st January 1970 UTC).</p> <p>This approach could potentially create a collision if two builds occur at precisely the same second, but it may be sufficient for many use cases:</p> <pre><code>--devrelease $(date +%s)\n</code></pre> <p>This will result in a unique developmental release of, for example:</p> <pre><code>1.3.2.dev1696238452\n</code></pre>"},{"location":"tutorials/github_actions/","title":"GitHub Actions","text":""},{"location":"tutorials/github_actions/#create-a-new-release-with-github-actions","title":"Create a new release with GitHub Actions","text":""},{"location":"tutorials/github_actions/#automatic-bumping-of-version","title":"Automatic bumping of version","text":"<p>To execute <code>cz bump</code> in your CI, and push the new commit and the new tag, back to your master branch, we have to:</p> <ol> <li>Create a personal access token. Follow the instructions here. And copy the generated key</li> <li>Create a secret called <code>PERSONAL_ACCESS_TOKEN</code>, with the copied key, by going to your    project repository and then <code>Settings &gt; Secrets &gt; Add new secret</code>.</li> <li>In your repository create a new file <code>.github/workflows/bumpversion.yml</code>    with the following content.</li> </ol> <p>Warning</p> <p>If you use <code>GITHUB_TOKEN</code> instead of <code>PERSONAL_ACCESS_TOKEN</code>, the job won't trigger another workflow. It's like using <code>[skip ci]</code> in other CI's.</p> <pre><code>name: Bump version\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  bump-version:\n    if: \"!startsWith(github.event.head_commit.message, 'bump:')\"\n    runs-on: ubuntu-latest\n    name: \"Bump version and create changelog with commitizen\"\n    steps:\n      - name: Check out\n        uses: actions/checkout@v3\n        with:\n          token: \"${{ secrets.PERSONAL_ACCESS_TOKEN }}\"\n          fetch-depth: 0\n      - name: Create bump and changelog\n        uses: commitizen-tools/commitizen-action@master\n        with:\n          github_token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n</code></pre> <p>Push to master and that's it.</p>"},{"location":"tutorials/github_actions/#creating-a-github-release","title":"Creating a GitHub release","text":"<p>You can modify the previous action.</p> <p>Add the variable <code>changelog_increment_filename</code> in the <code>commitizen-action</code>, specifying where to output the content of the changelog for the newly created version.</p> <p>And then add a step using a GitHub action to create the release: <code>softprops/action-gh-release</code></p> <p>Commitizen action creates an env variable called <code>REVISION</code>, containing the newly created version.</p> <pre><code>- name: Create bump and changelog\n  uses: commitizen-tools/commitizen-action@master\n  with:\n    github_token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n    changelog_increment_filename: body.md\n- name: Release\n  uses: softprops/action-gh-release@v1\n  with:\n    body_path: \"body.md\"\n    tag_name: ${{ env.REVISION }}\n  env:\n    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre>"},{"location":"tutorials/github_actions/#publishing-a-python-package","title":"Publishing a python package","text":"<p>Once the new tag is created, triggering an automatic publish command would be desired.</p> <p>In order to do so, the credential needs to be added with the information of our PyPI account.</p> <p>Instead of using username and password, we suggest using api token generated from PyPI.</p> <p>After generate api token, use the token as the PyPI password and <code>__token__</code> as the username.</p> <p>Go to <code>Settings &gt; Secrets &gt; Add new secret</code> and add the secret: <code>PYPI_PASSWORD</code>.</p> <p>Create a file in <code>.github/workflows/pythonpublish.yaml</code> with the following content:</p> <pre><code>name: Upload Python Package\n\non:\n  push:\n    tags:\n      - \"*\" # Will trigger for every tag, alternative: 'v*'\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.x\"\n      - name: Install Poetry\n        uses: snok/install-poetry@v1\n        with:\n          version: latest\n          virtualenvs-in-project: true\n          virtualenvs-create: true\n      - name: Install dependencies\n        run: |\n          poetry --version\n          poetry install\n      - name: Build and publish\n        env:\n          PYPI_USERNAME: __token__\n          PYPI_PASSWORD: ${{ secrets.PYPI_PASSWORD }}\n        run: |\n          ./scripts/publish\n</code></pre> <p>Notice that we are using poetry, and we are calling a bash script in <code>./scripts/publish</code>. You should configure the action, and publish with your tools (twine, poetry, etc.). Check Commitizen example You can also use pypa/gh-action-pypi-publish to publish your package.</p> <p>Push the changes and that's it.</p>"},{"location":"tutorials/gitlab_ci/","title":"GitLab CI","text":""},{"location":"tutorials/gitlab_ci/#create-a-new-release-using-gitlab-ci","title":"Create a new release using GitLab CI","text":"<p>For this example, we have a <code>python/django</code> application and <code>Docker</code> as a containerization tool.</p> <p>Goal: Bump a new version every time that a change occurs on the <code>master</code> branch. The bump should be executed automatically by the <code>CI</code> process.</p>"},{"location":"tutorials/gitlab_ci/#development-workflow","title":"Development Workflow","text":"<ol> <li>A developer creates a new commit on any branch (except <code>master</code>)</li> <li>A developer creates a merge request (MR) against <code>master</code> branch</li> <li>When the <code>MR</code> is merged into master, the 2 stages of the CI are executed</li> <li>For simplification, we store the software version in a file called <code>VERSION</code>. You can use any file that you want as <code>commitizen</code> supports it.</li> <li>The commit message executed automatically by the <code>CI</code> must include <code>[skip-ci]</code> in the message; otherwise, the process will generate a loop. You can define the message structure in commitizen as well.</li> </ol>"},{"location":"tutorials/gitlab_ci/#gitlab-configuration","title":"GitLab Configuration","text":"<p>To be able to change files and push new changes with <code>GitLab CI</code> runners, we need to have a <code>ssh</code> key and configure a git user.</p> <p>First, let's create a <code>ssh key</code>. The only requirement is to create it without a passphrase:</p> <pre><code>ssh-keygen -f deploy_key -N \"\"\n</code></pre> <p>The previous command will create a private and public key under the files <code>deploy_key</code> and <code>deploy_key.pub</code>. We will use them later.</p> <p>For the git user, we need an email and username. You can choose whatever you want; in this example, we choose <code>ci-runner@myproject.com</code> and <code>admin</code>, respectively.</p> <p>Now, we need to create three environment variables that will be visible for the runners. They should be created in the <code>variables</code> section under <code>settings/ci_cd</code>:</p> <p></p> <p>Create <code>SSH_PRIVATE_KEY</code>, <code>CI_EMAIL</code>, <code>CI_USERNAME</code> variables, and fill them with the <code>private_key</code>, <code>email</code> and <code>username</code> that we have created previously.</p> <p>The latest step is to create a <code>deploy key.</code> To do this, we should create it under the section <code>settings/repository</code> and fill it with the <code>public key</code> generated before. Check <code>Write access allowed</code>; otherwise, the runner won't be able to write the changes to the repository.</p> <p></p> <p>If you have more projects under the same organization, you can reuse the deploy key created before, but you will have to repeat the step where we have created the environment variables (ssh key, email, and username).</p> <p>Tip: If the CI raise some errors, try to unprotect the private key.</p>"},{"location":"tutorials/gitlab_ci/#defining-gitlab-ci-pipeline","title":"Defining GitLab CI Pipeline","text":"<ol> <li> <p>Create a <code>.gitlab-ci.yaml</code> file that contains <code>stages</code> and <code>jobs</code> configurations. You can find more info here.</p> </li> <li> <p>Define <code>stages</code> and <code>jobs</code>. For this example, we define two <code>stages</code> with one <code>job</code> each one.</p> </li> <li>Test the application.</li> <li>Auto bump the version. This means changing the file/s that reflects the version, creating a new commit and git tag.</li> </ol>"},{"location":"tutorials/gitlab_ci/#stages-and-jobs","title":"Stages and Jobs","text":"<pre><code>image: docker:latest\n\nservices:\n  - docker:dind\n\nvariables:\n  API_IMAGE_NAME: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME\n\nbefore_script:\n  - apk add --no-cache py-pip\n  - pip install docker-compose\n\nstages:\n  - test\n  - auto-bump\n\ntest:\n  stage: test\n  script:\n    - docker-compose run -e DJANGO_ENVIRONMENT=dev your_project python manage.py test # run tests\n\nauto-bump:\n  stage: auto-bump\n  image: python:3.9\n  before_script:\n    - \"which ssh-agent || ( apt-get update -qy &amp;&amp; apt-get install openssh-client -qqy )\"\n    - eval `ssh-agent -s`\n    - echo \"${SSH_PRIVATE_KEY}\" | tr -d '\\r' | ssh-add - &gt; /dev/null # add ssh key\n    - pip3 install -U commitizen # install commitizen\n    - mkdir -p ~/.ssh\n    - chmod 700 ~/.ssh\n    - echo \"$SSH_PUBLIC_KEY\" &gt;&gt; ~/.ssh/id_rsa.pub\n    - '[[ -f /.dockerenv ]] &amp;&amp; echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" &gt; ~/.ssh/config'\n  dependencies:\n    - test\n  script:\n    - git remote set-url origin git@gitlab.com:discover/rentee-core.git # git configuration\n    - git config --global user.email \"${CI_EMAIL}\" &amp;&amp; git config --global user.name \"${CI_USERNAME}\"\n    - 'exists=`git show-ref refs/heads/master` &amp;&amp; if [ -n \"$exists\" ]; then git branch -D master; fi'\n    - git checkout -b master\n    - cz bump --yes # execute auto bump and push to master\n    - git push origin master:$CI_COMMIT_REF_NAME\n    - TAG=$(head -n 1 VERSION) # get the new software version and save into artifacts\n    - echo \"#!/bin/sh\" &gt;&gt; variables\n    - echo \"export TAG='$TAG'\" &gt;&gt; variables\n    - git push origin $TAG\n  only:\n    refs:\n      - master\n  artifacts:\n    paths:\n      - variables\n</code></pre> <p>So, every time that a developer pushes to any branch, the <code>test</code> job is executed. If the branch is <code>master</code> and the test jobs succeed, the <code>auto-bump</code> takes place. To be able to push using the GitLab runner, we have to set the SSH key, configure git, and finally execute the auto bump.</p> <p>After merging the new changes into master, we have the final result:</p> <p></p>"},{"location":"tutorials/jenkins_pipeline/","title":"Create a new release with Jenkins Pipelines","text":"<p>For this we are using the modern approach of declarative pipelines.</p> <p>You must also ensure your jenkins instance supports docker. Most modern jenkins systems do have support for it, they have embraced it.</p> <pre><code>pipeline {\n  agent {\n    any\n  }\n  environment {\n    CI = 'true'\n  }\n  stages {\n    stage('Bump version') {\n      when {\n        beforeAgent true\n        expression { env.BRANCH_IS_PRIMARY }\n        not {\n          changelog '^bump:.+'\n        }\n      }\n      steps {\n        script {\n          useCz {\n            sh \"cz bump --changelog\"\n          }\n         // Here push back to your repository the new commit and tag\n        }\n      }\n    }\n  }\n}\n\ndef useCz(String authorName = 'Jenkins CI Server', String authorEmail = 'your-jenkins@email.com', String image =  'registry.hub.docker.com/commitizen/commitizen:latest', Closure body) {\n    docker\n    .image(image)\n    .inside(\"-u 0 -v $WORKSPACE:/workspace -w /workspace -e GIT_AUTHOR_NAME='${authorName}' -e GIT_AUTHOR_EMAIL='${authorEmail}' -entrypoint='/bin/sh'\") {\n        sh 'git config --global --add safe.directory \"*\"'\n        sh \"git config --global user.email '${authorName}'\"\n        sh \"git config --global user.name '${authorEmail}'\"\n        body()\n    }\n}\n</code></pre> <p>Warning</p> <p>Using jenkins pipeline with any git plugin may require many configurations, you'll have to tinker with it until your pipelines properly detects git events. Check your webhook in your git repository and check the \"behaviors\" and \"build strategies\" in your pipeline settings.</p>"},{"location":"tutorials/monorepo_guidance/","title":"Configuring Commitizen in a monorepo","text":"<p>This tutorial assumes the monorepo layout is designed with multiple components that can be released independently of each other, it also assumes that conventional commits with scopes are in use. Some suggested layouts:</p> <pre><code>.\n\u251c\u2500\u2500 library-b\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 .cz.toml\n\u2514\u2500\u2500 library-z\n    \u2514\u2500\u2500 .cz.toml\n</code></pre> <pre><code>src\n\u251c\u2500\u2500 library-b\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 .cz.toml\n\u2514\u2500\u2500 library-z\n    \u2514\u2500\u2500 .cz.toml\n</code></pre> <p>Sample <code>.cz.toml</code> for each component:</p> <pre><code># library-b/.cz.toml\n[tool.commitizen]\nname = \"cz_customize\"\nversion = \"0.0.0\"\ntag_format = \"${version}-library-b\" # the component name can be a prefix or suffix with or without a separator\nignored_tag_formats = [\"${version}-library-*\"] # Avoid noise from other tags\nupdate_changelog_on_bump = true\n</code></pre> <pre><code># library-z/.cz.toml\n[tool.commitizen]\nname = \"cz_customize\"\nversion = \"0.0.0\"\ntag_format = \"${version}-library-z\"\nignored_tag_formats = [\"${version}-library-*\"] # Avoid noise from other tags\nupdate_changelog_on_bump = true\n</code></pre> <p>And finally, to bump each of these:</p> <pre><code>cz --config library-b/.cz.toml bump --yes\ncz --config library-z/.cz.toml bump --yes\n</code></pre>"},{"location":"tutorials/monorepo_guidance/#changelog-per-component","title":"Changelog per component","text":"<p>In order to filter the correct commits for each component, you'll have to come up with a strategy.</p> <p>For example:</p> <ul> <li>Trigger the pipeline based on the changed path, which can have some downsides, as you'll rely on the developer not including files from other files<ul> <li>GitHub actions uses <code>path</code></li> <li>Jenkins uses <code>changeset</code></li> <li>GitLab uses <code>rules:changes</code></li> </ul> </li> <li>Filter certain pattern of the commit message (recommended)</li> </ul>"},{"location":"tutorials/monorepo_guidance/#example-with-scope-in-conventional-commits","title":"Example with scope in conventional commits","text":"<p>For this example, to include the message in the changelog, we will require commits to use a specific scope. This way, only relevant commits will be included in the appropriate change log for a given component, and any other commit will be ignored.</p> <p>Example config and commit for <code>library-b</code>:</p> <pre><code>[tool.commitizen.customize]\nchangelog_pattern = \"^(feat|fix)\\\\(library-b\\\\)(!)?:\" #the pattern on types can be a wild card or any types you wish to include\n</code></pre> <p>A commit message looking like this, would be included:</p> <pre><code>fix(library-b): Some awesome message\n</code></pre>"},{"location":"tutorials/tag_format/","title":"Managing tag formats","text":""},{"location":"tutorials/tag_format/#tag-format-and-version-scheme","title":"Tag format and version scheme","text":"<p>For most projects, the tag format is simply the version number which is set like this:</p> <pre><code>[tool.commitizen]\ntag_format: $version\nversion_scheme: pep440\n</code></pre> <p>As this is the default value, you don't have to specify it.</p> <p>This setting means that:</p> <ul> <li>The tag generated on bump will have this format: <code>1.0.0</code> :<ul> <li>the version is generated following PEP440 scheme</li> <li>the tag is exactly the generated version</li> </ul> </li> <li>All tags having this format will be recognized as version tag when:<ul> <li>searching the last while bumping a release</li> <li>searching previous versions while:<ul> <li>generating incremental changelog</li> <li>generating a changelog for a version range</li> </ul> </li> </ul> </li> <li>The changelog versions (section titles) will have this format</li> <li>The <code>scm</code> version provider will identify the current version using this tag format</li> </ul> <p>The version format will change depending on your configured version scheme. For most, it will only impact pre-releases and developmental releases formats (i.e. <code>1.0.0-rc.1</code> vs. <code>1.0.0.rc1</code>)</p> <p>But you may need a different tagging convention, let's say using <code>semver</code> and prefixed with a <code>v</code>. In this case you will define your settings like this:</p> <pre><code>[tool.commitizen]\ntag_format: v${version}\nversion_scheme: semver\n</code></pre> <p>As a result, the tag generated on bump will have this format: <code>v1.0.0</code> and the version will be generated following <code>semver</code> scheme.</p> <p>Note</p> <p>Both <code>$version</code> and <code>${version}</code> syntaxes are strictly equivalent. You can use the one you prefer.</p> <p>See the <code>version_scheme</code> section in <code>bump</code> command documentation for more details on version schemes and how to define your own. See <code>tag_format</code> and <code>version_scheme</code> settings in Configuration reference for more details on these settings.</p>"},{"location":"tutorials/tag_format/#changing-convention","title":"Changing convention","text":"<p>Now, let's say you need to change the tag format for some reason (company convention, migration to a monorepo...). You will obviously want to keep all those features working as expected.</p> <p>Commitizen can deal with it as long as you provide the legacy tag format in the configuration.</p> <p>Using the previous example, let's say you want to move from <code>v${version}</code> to <code>component-${version}</code>. Then <code>component-${version}</code> will be the new tag format and <code>v${version}</code> the legacy one.</p> <pre><code>[tool.commitizen]\ntag_format: component-${version}\nlegacy_tag_formats:\n - v${version}\n</code></pre> <p>This way, you won't lose your version history, you'll still be able to generate your changelog properly, and on the next version bump, your last version in the form <code>v${version}</code> will be properly recognized if you use the <code>scm</code> version provider. Your new tag will be in the form <code>component-${version}</code>.</p>"},{"location":"tutorials/tag_format/#known-tags-to-ignore","title":"Known tags to ignore","text":"<p>Now let's say you have some known tags you want to ignore, either because they are not versions, or because they are not versions of the component you are dealing with. As a consequence, you don't want them to trigger a warning because Commitizen detected an unknown tag format.</p> <p>Then you can tell Commitizen about it using the <code>ignored_tag_formats</code> setting:</p> <pre><code>[tool.commitizen]\nignored_tag_formats:\n  - prod\n  - other-component-${version}\n  - prefix-*\n</code></pre> <p>This will ignore:</p> <ul> <li>The <code>prod</code> tag</li> <li>Any version tag prefixed with <code>other-component-</code></li> <li>Any tag prefixed with <code>prefix-</code></li> </ul> <p>Tip</p> <p>Note the <code>*</code> in the <code>prefix-*</code> pattern. This is a wildcard and only exists for <code>ignored_tag_formats</code>. It will match any string from any length. This allows to exclude by prefix, whether it is followed by a version or not.</p> <p>Tip</p> <p>If you don't want to be warned when Commitizen detects an unknown tag, you can do so by setting: <pre><code>[tool.commitizen]\nignored_tag_formats = [\"*\"]\n</code></pre> But be aware that you will not be warned if you have a typo in your tag formats.</p>"},{"location":"tutorials/writing_commits/","title":"Writing commits","text":"<p>For this project to work well in your pipeline, a commit convention must be followed.</p> <p>By default, Commitizen uses the known conventional commits, but you can create your own following the documentation information over at customization.</p>"},{"location":"tutorials/writing_commits/#conventional-commits","title":"Conventional commits","text":"<p>If you are using conventional commits, the most important thing to know is that you must begin your commits with at least one of these tags: <code>fix</code>, <code>feat</code>. And if you introduce a breaking change, then you must add to your commit body the following <code>BREAKING CHANGE</code>. Using these three keywords will allow the proper identification of the semantic version. Of course, there are other keywords, but I'll leave it to the reader to explore them.</p>"},{"location":"tutorials/writing_commits/#writing-commits","title":"Writing commits","text":"<p>Now to the important part: when writing commits, it's important to think about:</p> <ul> <li>Your future self</li> <li>Your colleagues</li> </ul> <p>You may think this is trivial, but it's not. It's important for the reader to understand what happened.</p> <p>Emojis may be added as well (e.g., see cz-emoji), which requires the <code>utf-8</code>, or equivalent, character encoding to support unicode characters. By default, <code>commitizen</code> uses the <code>utf-8</code> character encoding, but a different encoding may be set through the <code>encoding</code> configuration option.</p>"},{"location":"tutorials/writing_commits/#recommendations","title":"Recommendations","text":"<ul> <li>Keep the message short: Makes the list of commits more readable (~50 chars).</li> <li>Talk imperative: Follow this rule: <code>If applied, this commit will &lt;commit message&gt;</code></li> <li>Think about the CHANGELOG: Your commits will probably end up in the changelog,   so try writing for it, but also keep in mind that you can skip sending commits to the   CHANGELOG by using different keywords (like <code>build</code>).</li> <li>Use a commit per new feature: If you introduce multiple things related to the same   commit, squash them. This is useful for auto-generating CHANGELOG.</li> </ul> Do's Don'ts <code>fix(commands): bump error when no user provided</code> <code>fix: stuff</code> <code>feat: add new commit command</code> <code>feat: commit command introduced</code>"}]}